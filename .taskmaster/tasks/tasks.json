{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize Next.js 14+ project with TypeScript, configure Tailwind CSS and shadcn/ui, and set up the basic project structure.",
        "details": "1. Create a new Next.js project with TypeScript:\n```bash\nnpx create-next-app@latest pack-list --typescript --tailwind --eslint\n```\n2. Install and configure shadcn/ui:\n```bash\nnpm install @shadcn/ui\nnpx shadcn-ui init\n```\n3. Set up Zustand for state management:\n```bash\nnpm install zustand\n```\n4. Set up React Query for server state:\n```bash\nnpm install @tanstack/react-query\n```\n5. Configure project structure:\n   - `/app`: Next.js app router pages\n   - `/components`: Reusable UI components\n   - `/lib`: Utility functions and hooks\n   - `/store`: Zustand store definitions\n   - `/types`: TypeScript type definitions\n6. Set up basic layout components with responsive design\n7. Configure dark mode support with Tailwind",
        "testStrategy": "1. Verify all dependencies are correctly installed\n2. Ensure the project builds without errors\n3. Test responsive layout on different screen sizes\n4. Validate dark mode toggle functionality\n5. Run TypeScript type checking to ensure proper configuration",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Next.js Installation and Initial Configuration",
            "description": "Set up a new Next.js 14+ project with TypeScript and configure the basic development environment.",
            "dependencies": [],
            "details": "1. Create a new Next.js project with TypeScript support:\n```bash\nnpx create-next-app@latest pack-list --typescript --tailwind --eslint\n```\n2. Navigate to the project directory:\n```bash\ncd pack-list\n```\n3. Install additional development dependencies:\n```bash\nnpm install -D @types/node @types/react @types/react-dom\n```\n4. Configure ESLint and Prettier for code quality\n5. Test the installation by running the development server:\n```bash\nnpm run dev\n```",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "UI Library Setup with Tailwind and shadcn/ui",
            "description": "Configure Tailwind CSS and install shadcn/ui components for the user interface.",
            "dependencies": [],
            "details": "1. Verify Tailwind CSS is properly configured in tailwind.config.js\n2. Install shadcn/ui:\n```bash\nnpm install @shadcn/ui\nnpx shadcn-ui init\n```\n3. Configure shadcn/ui according to project requirements:\n   - Select appropriate color scheme\n   - Configure component locations\n   - Set up typography settings\n4. Install and configure common UI components:\n```bash\nnpx shadcn-ui add button\nnpx shadcn-ui add card\nnpx shadcn-ui add form\nnpx shadcn-ui add input\n```\n5. Create a basic UI component test page to verify installation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "State Management Setup",
            "description": "Implement Zustand for client-side state management and React Query for server state management.",
            "dependencies": [],
            "details": "1. Install Zustand for client-side state management:\n```bash\nnpm install zustand\n```\n2. Install React Query for server state management:\n```bash\nnpm install @tanstack/react-query\n```\n3. Set up a basic Zustand store:\n```typescript\n// store/useStore.ts\nimport { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\n\ninterface AppState {\n  // Define your state here\n}\n\nexport const useAppStore = create<AppState>(\n  persist(\n    (set) => ({\n      // Initial state and actions\n    }),\n    { name: 'app-storage' }\n  )\n)\n```\n4. Configure React Query provider in the app layout",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Project Structure and Dark Mode Implementation",
            "description": "Organize the project structure and implement dark mode support with Tailwind CSS.",
            "dependencies": [],
            "details": "1. Set up the project directory structure:\n   - `/app`: Next.js app router pages\n   - `/components`: Reusable UI components\n   - `/lib`: Utility functions and hooks\n   - `/store`: Zustand store definitions\n   - `/types`: TypeScript type definitions\n\n2. Create basic layout components with responsive design:\n```typescript\n// components/layout/MainLayout.tsx\n// components/layout/Header.tsx\n// components/layout/Footer.tsx\n```\n\n3. Implement dark mode support:\n   - Configure Tailwind for dark mode in tailwind.config.js\n   - Create a theme toggle component\n   - Implement theme persistence with localStorage\n\n4. Set up a ThemeProvider component to manage theme state globally",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Data Models and State Management",
        "description": "Implement TypeScript interfaces for data models and set up Zustand stores for state management with local storage persistence.",
        "details": "1. Create TypeScript interfaces for data models:\n```typescript\n// types/models.ts\nexport interface User {\n  id: string;\n  email?: string;\n  name?: string;\n  createdAt: Date;\n}\n\nexport interface List {\n  id: string;\n  userId?: string;\n  name: string;\n  description?: string;\n  isTemplate: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Category {\n  id: string;\n  listId: string;\n  name: string;\n  order: number;\n}\n\nexport enum Priority {\n  ESSENTIAL = 'essential',\n  NICE_TO_HAVE = 'nice-to-have',\n  OPTIONAL = 'optional'\n}\n\nexport interface Item {\n  id: string;\n  categoryId: string;\n  name: string;\n  quantity: number;\n  priority: Priority;\n  isPacked: boolean;\n  notes?: string;\n}\n\nexport interface Template {\n  id: string;\n  name: string;\n  description?: string;\n  categories: Omit<Category, 'listId'>[];\n  items: Omit<Item, 'categoryId'>[];\n  isPublic: boolean;\n}\n```\n\n2. Create Zustand store with local storage persistence:\n```typescript\n// store/listStore.ts\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { List, Category, Item } from '../types/models';\nimport { v4 as uuidv4 } from 'uuid';\n\ninterface ListState {\n  lists: List[];\n  categories: Category[];\n  items: Item[];\n  // Actions\n  createList: (name: string, description?: string, isTemplate?: boolean) => string;\n  updateList: (id: string, updates: Partial<Omit<List, 'id'>>) => void;\n  deleteList: (id: string) => void;\n  // Category actions\n  addCategory: (listId: string, name: string) => string;\n  updateCategory: (id: string, updates: Partial<Omit<Category, 'id'>>) => void;\n  deleteCategory: (id: string) => void;\n  // Item actions\n  addItem: (categoryId: string, name: string, quantity?: number, priority?: Priority) => string;\n  updateItem: (id: string, updates: Partial<Omit<Item, 'id'>>) => void;\n  deleteItem: (id: string) => void;\n  toggleItemPacked: (id: string) => void;\n}\n\nexport const useListStore = create<ListState>(\n  persist(\n    (set, get) => ({\n      lists: [],\n      categories: [],\n      items: [],\n      \n      createList: (name, description = '', isTemplate = false) => {\n        const id = uuidv4();\n        const newList: List = {\n          id,\n          name,\n          description,\n          isTemplate,\n          createdAt: new Date(),\n          updatedAt: new Date()\n        };\n        set(state => ({ lists: [...state.lists, newList] }));\n        return id;\n      },\n      \n      // Implement other actions...\n      \n    }),\n    {\n      name: 'pack-list-storage',\n    }\n  )\n);\n```\n\n3. Implement remaining store actions for CRUD operations\n4. Create utility functions for calculating list statistics (completion percentage, etc.)",
        "testStrategy": "1. Unit test all store actions with Jest\n2. Test local storage persistence by simulating browser refresh\n3. Verify data integrity when performing CRUD operations\n4. Test edge cases like empty lists, duplicate items, etc.\n5. Validate type safety with TypeScript compiler",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core Data Model Interfaces",
            "description": "Create TypeScript interfaces for all data models including User, List, Category, Item, Template, and Priority enum.",
            "dependencies": [],
            "details": "1. Create a types/models.ts file\n2. Define User interface with id, email, name, and createdAt fields\n3. Define List interface with all required properties\n4. Define Category interface with id, listId, name, and order fields\n5. Create Priority enum with ESSENTIAL, NICE_TO_HAVE, and OPTIONAL values\n6. Define Item interface with all required properties\n7. Define Template interface for list templates\n8. Add proper TypeScript typing for all fields\n9. Add JSDoc comments for better code documentation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set Up Zustand Store with Persistence",
            "description": "Create the basic Zustand store structure with local storage persistence middleware and define the state interface.",
            "dependencies": [],
            "details": "1. Install required dependencies: zustand, uuid\n2. Create store/listStore.ts file\n3. Define ListState interface with all state properties and action types\n4. Set up the basic store with persist middleware\n5. Configure local storage persistence with appropriate storage key\n6. Initialize empty arrays for lists, categories, and items\n7. Export the store hook for use in components\n8. Add TypeScript type safety throughout the store implementation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement List Management Actions",
            "description": "Implement all CRUD operations for list management in the Zustand store.",
            "dependencies": [],
            "details": "1. Implement createList function that generates a UUID and creates a new list\n2. Implement updateList function to modify list properties\n3. Implement deleteList function that removes a list and its associated categories and items\n4. Add error handling for all list operations\n5. Ensure proper state immutability in all actions\n6. Add validation for required fields\n7. Implement proper date handling for createdAt and updatedAt fields",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Category and Item CRUD Operations",
            "description": "Implement all actions for managing categories and items within lists, including adding, updating, deleting, and toggling packed status.",
            "dependencies": [],
            "details": "1. Implement addCategory function with proper list association\n2. Implement updateCategory function for modifying category properties\n3. Implement deleteCategory function that also removes associated items\n4. Implement addItem function with category association\n5. Implement updateItem function for modifying item properties\n6. Implement deleteItem function\n7. Implement toggleItemPacked function for checking/unchecking items\n8. Add proper error handling and validation for all operations\n9. Ensure correct order handling for categories",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create Statistics Calculation Utilities",
            "description": "Develop utility functions for calculating list statistics such as completion percentage, item counts by priority, and category progress.",
            "dependencies": [],
            "details": "1. Create lib/statisticsUtils.ts file\n2. Implement calculateListProgress function to determine overall completion percentage\n3. Implement calculateCategoryProgress function for individual category progress\n4. Create getItemsByPriority function to group items by priority level\n5. Implement getPackedItemCount and getTotalItemCount utilities\n6. Create getListSummary function that returns comprehensive statistics for a list\n7. Add proper TypeScript typing for all utility functions\n8. Write JSDoc comments for all functions\n9. Ensure efficient calculations that can handle large lists",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "List Management UI Components",
        "description": "Develop UI components for creating, viewing, and managing packing lists, including list creation forms and list overview screens.",
        "details": "1. Create reusable components:\n```typescript\n// components/lists/CreateListForm.tsx\n// Form for creating new lists with name, description fields\n\n// components/lists/ListCard.tsx\n// Card component displaying list summary with actions\n\n// components/lists/ListOverview.tsx\n// Component to display all user lists with filtering options\n\n// components/lists/ListDetail.tsx\n// Detailed view of a single list with categories and items\n```\n\n2. Implement list creation flow:\n   - Modal/form for creating new lists\n   - Option to create from scratch or from template\n   - Form validation for required fields\n\n3. Implement list overview page:\n   - Grid/list view of all user lists\n   - Sort by name, date created, completion status\n   - Quick actions (duplicate, delete, export)\n\n4. Create list detail view:\n   - Header with list name, description, progress\n   - Section for categories\n   - Add category button\n   - List statistics (total items, packed items, etc.)\n\n5. Add list actions:\n   - Edit list properties\n   - Delete list with confirmation\n   - Save as template\n   - Duplicate list",
        "testStrategy": "1. Component testing with React Testing Library\n2. Test form validation for required fields\n3. Test user interactions (clicks, form submissions)\n4. Verify responsive design on different screen sizes\n5. Test accessibility with keyboard navigation and screen readers\n6. Verify proper state updates when performing actions",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement List Creation Form and Modal",
            "description": "Develop the form and modal components for creating new packing lists, including validation and template options.",
            "dependencies": [],
            "details": "1. Create `CreateListForm.tsx` component with name and description fields\n2. Implement form validation for required fields\n3. Build modal component to contain the form\n4. Add option to create from scratch or from template\n5. Connect form submission to state management\n6. Implement responsive design for mobile and desktop\n7. Add proper accessibility attributes and keyboard navigation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop List Card and Overview Components",
            "description": "Create components for displaying list summaries and the overview page with filtering and sorting options.",
            "dependencies": [],
            "details": "1. Implement `ListCard.tsx` component showing list summary with actions\n2. Create `ListOverview.tsx` component to display all user lists\n3. Add filtering options (by name, date, completion status)\n4. Implement sorting functionality (name, date created, completion)\n5. Add quick action buttons (duplicate, delete, export)\n6. Ensure responsive grid/list view layout\n7. Implement loading states and empty states",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build List Detail View with Statistics",
            "description": "Create the detailed view component for a single list, including header, categories section, and statistics.",
            "dependencies": [],
            "details": "1. Develop `ListDetail.tsx` component for detailed list view\n2. Create header section with list name, description, and progress\n3. Implement categories section with proper styling\n4. Add 'Add category' button and functionality\n5. Create list statistics section (total items, packed items, etc.)\n6. Ensure responsive layout for all screen sizes\n7. Implement proper loading and error states",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement List Action Handlers",
            "description": "Create functionality for list actions including editing, deleting, saving as template, and duplicating lists.",
            "dependencies": [],
            "details": "1. Implement edit list properties functionality\n2. Create delete list action with confirmation dialog\n3. Develop save as template functionality\n4. Implement duplicate list action\n5. Connect all actions to state management\n6. Add proper error handling for all operations\n7. Ensure all actions have appropriate feedback (toasts, loading states)",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Item and Category Management",
        "description": "Implement UI components and functionality for managing categories and items within lists, including CRUD operations and drag-and-drop reordering.",
        "details": "1. Create category components:\n```typescript\n// components/categories/CategorySection.tsx\n// Collapsible section for category with items\n\n// components/categories/CategoryForm.tsx\n// Form for adding/editing categories\n```\n\n2. Create item components:\n```typescript\n// components/items/ItemRow.tsx\n// Component for displaying and interacting with a single item\n\n// components/items/ItemForm.tsx\n// Form for adding/editing items with all properties\n\n// components/items/ItemList.tsx\n// List of items within a category with virtualization for performance\n```\n\n3. Implement drag-and-drop reordering:\n```bash\nnpm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities\n```\n\n```typescript\n// components/dnd/SortableItem.tsx\n// Wrapper component for making items sortable\n\n// components/dnd/SortableCategory.tsx\n// Wrapper component for making categories sortable\n```\n\n4. Implement inline editing for quick updates\n5. Add quantity controls with increment/decrement buttons\n6. Create priority selection dropdown (essential, nice-to-have, optional)\n7. Implement check-off functionality with animations\n8. Add swipe gestures for mobile (mark as packed, delete)",
        "testStrategy": "1. Test CRUD operations for categories and items\n2. Verify drag-and-drop functionality works correctly\n3. Test inline editing and form validation\n4. Verify mobile swipe gestures work as expected\n5. Test check-off functionality and state updates\n6. Verify keyboard accessibility for all interactions\n7. Test performance with large lists using React profiler",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Category Components Implementation",
            "description": "Create and implement the category-related UI components for managing categories within lists.",
            "dependencies": [],
            "details": "1. Implement CategorySection.tsx as a collapsible section that displays category title and contains items\n2. Create CategoryForm.tsx for adding and editing categories with validation\n3. Add functionality to delete categories with confirmation\n4. Implement category header with edit/delete controls\n5. Add collapsible animation for expanding/collapsing categories\n6. Ensure proper state management for categories using Zustand",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Item Components with Controls",
            "description": "Develop item-related components with priority selection and quantity controls.",
            "dependencies": [],
            "details": "1. Implement ItemRow.tsx for displaying individual items with all properties\n2. Create ItemForm.tsx with fields for name, description, quantity, priority, etc.\n3. Add quantity controls with increment/decrement buttons\n4. Implement priority selection dropdown (essential, nice-to-have, optional)\n5. Create check-off functionality with animations for completed items\n6. Implement ItemList.tsx with virtualization for performance with large lists\n7. Add proper validation for all item form fields",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Drag-and-Drop Reordering",
            "description": "Implement drag-and-drop functionality for reordering both categories and items using dnd-kit.",
            "dependencies": [],
            "details": "1. Install required packages: @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities\n2. Create SortableItem.tsx wrapper component for making items draggable\n3. Implement SortableCategory.tsx for category reordering\n4. Add drag handles and visual feedback during dragging operations\n5. Implement state updates when items/categories are reordered\n6. Ensure keyboard accessibility for drag-and-drop operations\n7. Add animations for smooth transitions during reordering",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Inline Editing Functionality",
            "description": "Implement inline editing capabilities for quick updates to items and categories without opening forms.",
            "dependencies": [],
            "details": "1. Create editable text components for item and category names\n2. Implement click-to-edit functionality for quick text updates\n3. Add auto-focus and blur handling for edit fields\n4. Implement keyboard shortcuts for confirming/canceling edits\n5. Add validation for inline edits\n6. Ensure proper state updates when inline edits are confirmed\n7. Create smooth transitions between view and edit modes",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Mobile Swipe Gestures",
            "description": "Implement touch-based swipe gestures for mobile devices to perform common actions on items.",
            "dependencies": [],
            "details": "1. Research and select appropriate library for handling swipe gestures\n2. Implement swipe-right to mark items as packed/unpacked\n3. Add swipe-left for delete functionality with confirmation\n4. Create visual feedback during swipe operations\n5. Ensure proper haptic feedback on mobile devices\n6. Add animation for revealing action buttons during partial swipes\n7. Implement fallback UI for non-touch devices\n8. Test on various mobile devices and screen sizes",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Progress Tracking and Visualization",
        "description": "Implement visual indicators for tracking packing progress, including progress bars, completion percentages, and status indicators.",
        "details": "1. Create progress tracking components:\n```typescript\n// components/progress/ProgressBar.tsx\n// Visual progress bar with percentage\n\n// components/progress/CategoryProgress.tsx\n// Progress indicator for individual categories\n\n// components/progress/ListProgress.tsx\n// Overall list progress with statistics\n```\n\n2. Implement progress calculation utilities:\n```typescript\n// lib/progressUtils.ts\nexport const calculateListProgress = (items: Item[]): number => {\n  if (items.length === 0) return 0;\n  const packedItems = items.filter(item => item.isPacked).length;\n  return Math.round((packedItems / items.length) * 100);\n};\n\nexport const calculateCategoryProgress = (items: Item[], categoryId: string): number => {\n  const categoryItems = items.filter(item => item.categoryId === categoryId);\n  return calculateListProgress(categoryItems);\n};\n\nexport const getProgressColor = (progress: number): string => {\n  if (progress < 30) return 'bg-red-500';\n  if (progress < 70) return 'bg-yellow-500';\n  return 'bg-green-500';\n};\n```\n\n3. Add visual indicators:\n   - Color-coded progress bars\n   - Completion checkmarks\n   - Category collapse/expand based on completion\n   - Confetti animation on list completion\n\n4. Implement priority visualization:\n   - Color-coded or icon-based indicators for item priority\n   - Sorting options based on priority\n   - Filter by priority level",
        "testStrategy": "1. Unit test progress calculation functions\n2. Test progress updates when items are checked/unchecked\n3. Verify visual indicators update correctly\n4. Test edge cases (empty lists, all items checked)\n5. Verify animations trigger at appropriate times\n6. Test color accessibility for visual indicators\n7. Verify sorting and filtering by priority works correctly",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Progress Calculation Utilities",
            "description": "Develop and test the utility functions for calculating progress percentages for lists and categories.",
            "dependencies": [],
            "details": "1. Create the `progressUtils.ts` file with the following functions:\n- `calculateListProgress`: Calculate overall progress percentage for a list\n- `calculateCategoryProgress`: Calculate progress for a specific category\n- `getProgressColor`: Return appropriate color class based on progress percentage\n\n2. Add additional utility functions:\n- `getCompletionStatus`: Return text status (Not Started/In Progress/Complete)\n- `getItemsStats`: Return object with counts of total, packed, and remaining items\n\n3. Write unit tests for all utility functions including edge cases (empty lists, all items packed, etc.)",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Visual Progress Indicator Components",
            "description": "Develop reusable components for displaying progress visually through bars, percentages, and color-coding.",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Implement the following components:\n- `ProgressBar.tsx`: Reusable progress bar with percentage display\n- `CategoryProgress.tsx`: Progress indicator for individual categories\n- `ListProgress.tsx`: Overall list progress with statistics\n\n2. Add visual enhancements:\n- Color-coded progress bars using the utility functions\n- Completion checkmarks for finished categories\n- Category collapse/expand functionality based on completion status\n- Confetti animation that triggers when a list reaches 100% completion\n\n3. Ensure all components are responsive and accessible",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Priority Visualization and Sorting",
            "description": "Add visual indicators for item priorities and implement sorting/filtering options based on priority levels.",
            "dependencies": [
              "5.2"
            ],
            "details": "1. Create priority visualization components:\n- Priority indicators using colors and/or icons\n- Legend explaining priority levels\n\n2. Implement priority-based functionality:\n- Sorting options to arrange items by priority level\n- Filtering controls to show only items of specific priorities\n- Quick priority toggle in item components\n\n3. Update existing components to incorporate priority visualization\n- Add priority indicators to ItemRow component\n- Include priority filters in list views",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Template Library Implementation",
        "description": "Create a library of pre-built packing list templates for common scenarios and implement functionality for users to save and reuse their own templates.",
        "details": "1. Create default templates data:\n```typescript\n// data/defaultTemplates.ts\nimport { Template, Priority } from '../types/models';\n\nexport const defaultTemplates: Template[] = [\n  {\n    id: 'beach-vacation',\n    name: 'Beach Vacation',\n    description: 'Essential items for a beach getaway',\n    isPublic: true,\n    categories: [\n      { id: 'beach-clothing', name: 'Clothing', order: 0 },\n      { id: 'beach-toiletries', name: 'Toiletries', order: 1 },\n      { id: 'beach-accessories', name: 'Beach Accessories', order: 2 },\n      { id: 'beach-documents', name: 'Documents', order: 3 },\n    ],\n    items: [\n      { id: 'item-1', name: 'Swimsuit', quantity: 2, priority: Priority.ESSENTIAL, isPacked: false, categoryId: 'beach-clothing' },\n      { id: 'item-2', name: 'Sunscreen', quantity: 1, priority: Priority.ESSENTIAL, isPacked: false, categoryId: 'beach-toiletries' },\n      // Add more template items...\n    ]\n  },\n  // Add more templates (business trip, camping, etc.)\n];\n```\n\n2. Create template browsing UI:\n```typescript\n// components/templates/TemplateLibrary.tsx\n// Grid view of available templates with search/filter\n\n// components/templates/TemplateCard.tsx\n// Card displaying template info with preview and use button\n\n// components/templates/TemplatePreviewer.tsx\n// Modal to preview template contents before using\n```\n\n3. Implement template management:\n   - Save current list as template\n   - Apply template to create new list\n   - Modify template items before creating list\n   - Combine multiple templates\n\n4. Add template categories:\n   - Travel (business, leisure)\n   - Outdoor activities (camping, hiking)\n   - Events (wedding, conference)\n   - Seasonal (summer, winter)",
        "testStrategy": "1. Verify all default templates load correctly\n2. Test template application to create new lists\n3. Test saving custom lists as templates\n4. Verify template preview functionality\n5. Test template search and filtering\n6. Verify template modifications persist correctly\n7. Test template combination functionality",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Default Templates Data Structure",
            "description": "Implement a comprehensive library of pre-built packing list templates for common scenarios like travel, outdoor activities, events, and seasonal needs.",
            "dependencies": [],
            "details": "1. Complete the defaultTemplates.ts file with at least 5-7 template options\n2. Ensure each template has appropriate categories and items\n3. Add metadata like difficulty, duration, and tags to templates\n4. Create TypeScript interfaces for template-related types\n5. Implement utility functions for template validation and processing",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Template Browsing and Preview UI",
            "description": "Create the user interface components for browsing, searching, filtering, and previewing templates before application.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. Implement TemplateLibrary component with grid/list view options\n2. Create TemplateCard component with preview thumbnail and metadata\n3. Build TemplatePreviewer modal with detailed template contents\n4. Add search and filter functionality by category, popularity, and tags\n5. Implement responsive design for mobile template browsing",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Template Application and Customization",
            "description": "Create functionality to apply templates to create new lists, customize templates before application, and save current lists as templates.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "1. Implement 'Apply Template' functionality to create new lists\n2. Add template customization options before application\n3. Create 'Save as Template' feature for current lists\n4. Implement template combination functionality to merge multiple templates\n5. Add template modification and versioning capabilities",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Template Categorization and Management",
            "description": "Implement template categorization, organization features, and template management functionality for user-created templates.",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3"
            ],
            "details": "1. Implement template categories (Travel, Outdoor, Events, Seasonal)\n2. Create template tagging system for better organization\n3. Add template favoriting and popularity tracking\n4. Implement user template management (edit, delete, share)\n5. Add template import/export functionality",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Search, Filter, and Duplicate Detection",
        "description": "Implement search functionality across lists and items, filtering options, and duplicate item detection to improve user experience.",
        "details": "1. Create search components:\n```typescript\n// components/search/SearchBar.tsx\n// Search input with options and results display\n\n// components/search/FilterControls.tsx\n// UI for applying various filters to lists and items\n```\n\n2. Implement search functionality:\n```typescript\n// lib/searchUtils.ts\nexport const searchItems = (items: Item[], query: string): Item[] => {\n  const lowerQuery = query.toLowerCase();\n  return items.filter(item => \n    item.name.toLowerCase().includes(lowerQuery) ||\n    item.notes?.toLowerCase().includes(lowerQuery)\n  );\n};\n\nexport const searchLists = (lists: List[], query: string): List[] => {\n  const lowerQuery = query.toLowerCase();\n  return lists.filter(list => \n    list.name.toLowerCase().includes(lowerQuery) ||\n    list.description?.toLowerCase().includes(lowerQuery)\n  );\n};\n```\n\n3. Implement filtering options:\n   - By category\n   - By priority\n   - By packed status\n   - By date created/modified\n\n4. Create duplicate detection:\n```typescript\n// lib/duplicateUtils.ts\nexport const findPotentialDuplicates = (items: Item[], newItemName: string): Item[] => {\n  const normalized = newItemName.toLowerCase().trim();\n  return items.filter(item => {\n    const itemName = item.name.toLowerCase().trim();\n    return itemName === normalized || \n           levenshteinDistance(itemName, normalized) <= 2 || // Allow for minor typos\n           itemName.includes(normalized) || \n           normalized.includes(itemName);\n  });\n};\n\n// Simple Levenshtein distance implementation for fuzzy matching\nfunction levenshteinDistance(a: string, b: string): number {\n  // Implementation details...\n}\n```\n\n5. Implement duplicate warning UI:\n   - Modal/tooltip showing potential duplicates\n   - Option to add anyway or cancel\n   - Smart suggestions for similar items",
        "testStrategy": "1. Test search functionality with various queries\n2. Verify filtering works correctly with multiple criteria\n3. Test duplicate detection with similar item names\n4. Verify fuzzy matching for typos and variations\n5. Test search performance with large datasets\n6. Verify UI updates correctly when applying filters\n7. Test duplicate warning UI and user interactions",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Search Components and Functionality",
            "description": "Create search bar UI components and implement the core search functionality for both items and lists.",
            "dependencies": [],
            "details": "1. Develop SearchBar.tsx component with input field, search button, and results display\n2. Implement search functionality in searchUtils.ts for both items and lists\n3. Add keyboard shortcuts for search (Ctrl+F/Cmd+F)\n4. Create search results display component with highlighting of matched terms\n5. Implement search history tracking for quick access to previous searches\n6. Add real-time search as user types with debouncing for performance",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Develop Filter Controls and Filtering Logic",
            "description": "Create UI components for filtering and implement the filtering logic for various criteria.",
            "dependencies": [
              "7.1"
            ],
            "details": "1. Build FilterControls.tsx component with various filter options\n2. Implement filtering by category, priority, packed status, and date\n3. Create filter persistence using URL parameters or local storage\n4. Add multi-select filter capabilities\n5. Implement filter combination logic (AND/OR operations)\n6. Create visual indicators for active filters\n7. Add filter presets for common filtering scenarios",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Duplicate Detection Algorithm",
            "description": "Create the duplicate detection algorithm with Levenshtein distance for fuzzy matching of similar items.",
            "dependencies": [],
            "details": "1. Implement the Levenshtein distance algorithm in duplicateUtils.ts\n2. Create findPotentialDuplicates function to detect similar items\n3. Optimize algorithm performance for large datasets\n4. Add configurable sensitivity settings for duplicate detection\n5. Implement normalized string comparison to handle case differences and special characters\n6. Add support for detecting duplicates across different lists\n7. Create unit tests for the duplicate detection algorithm",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Duplicate Warning UI and Interaction Handling",
            "description": "Develop the UI components and interaction flow for warning users about potential duplicates and handling their decisions.",
            "dependencies": [
              "7.3"
            ],
            "details": "1. Create modal/tooltip component for displaying potential duplicates\n2. Implement UI for showing similar items with highlighting of similarities\n3. Add options to add anyway, cancel, or use existing item\n4. Create smart suggestions for similar items\n5. Implement feedback mechanism to improve duplicate detection\n6. Add settings to configure duplicate detection sensitivity\n7. Ensure accessibility of duplicate warning UI",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Export and Sharing Functionality",
        "description": "Implement functionality to export lists in different formats (PDF, text) and generate shareable links for collaborative packing.",
        "details": "1. Install necessary dependencies:\n```bash\nnpm install jspdf html-to-image file-saver\n```\n\n2. Create export utilities:\n```typescript\n// lib/exportUtils.ts\nimport { jsPDF } from 'jspdf';\nimport { toPng } from 'html-to-image';\nimport { saveAs } from 'file-saver';\nimport { List, Category, Item } from '../types/models';\n\nexport const exportAsPDF = async (listId: string, elementRef: React.RefObject<HTMLElement>) => {\n  if (!elementRef.current) return;\n  \n  const pdf = new jsPDF('p', 'mm', 'a4');\n  const canvas = await toPng(elementRef.current);\n  \n  const imgProps = pdf.getImageProperties(canvas);\n  const pdfWidth = pdf.internal.pageSize.getWidth();\n  const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;\n  \n  pdf.addImage(canvas, 'PNG', 0, 0, pdfWidth, pdfHeight);\n  pdf.save(`packing-list-${listId}.pdf`);\n};\n\nexport const exportAsText = (list: List, categories: Category[], items: Item[]) => {\n  let content = `${list.name}\\n${'='.repeat(list.name.length)}\\n\\n`;\n  \n  if (list.description) {\n    content += `${list.description}\\n\\n`;\n  }\n  \n  const listCategories = categories.filter(c => c.listId === list.id);\n  \n  listCategories.forEach(category => {\n    content += `## ${category.name}\\n`;\n    \n    const categoryItems = items.filter(item => item.categoryId === category.id);\n    categoryItems.forEach(item => {\n      const status = item.isPacked ? '[x]' : '[ ]';\n      content += `${status} ${item.quantity > 1 ? `${item.quantity}x ` : ''}${item.name}${item.priority !== 'nice-to-have' ? ` (${item.priority})` : ''}\\n`;\n    });\n    \n    content += '\\n';\n  });\n  \n  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });\n  saveAs(blob, `packing-list-${list.id}.txt`);\n};\n```\n\n3. Create print-friendly view:\n```typescript\n// components/export/PrintView.tsx\n// Clean, printer-optimized view of the list\n\n// app/print/[listId]/page.tsx\n// Dedicated print page with minimal UI\n```\n\n4. Implement sharing functionality:\n   - Generate unique shareable URLs\n   - Create view-only mode for shared lists\n   - Add copy-to-clipboard functionality\n   - Implement QR code generation for easy mobile sharing",
        "testStrategy": "1. Test PDF export with various list sizes and content\n2. Verify text export format is readable and complete\n3. Test print view rendering and print media CSS\n4. Verify sharing links work correctly\n5. Test view-only mode security and permissions\n6. Verify QR code generation and scanning\n7. Test copy-to-clipboard functionality across browsers",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "PDF Export Implementation",
            "description": "Implement the PDF export functionality using jsPDF and html-to-image libraries",
            "dependencies": [],
            "details": "1. Complete the exportAsPDF function in exportUtils.ts\n2. Create a UI component for triggering PDF exports\n3. Add error handling for PDF generation failures\n4. Implement loading states during PDF generation\n5. Test with various list sizes and content types\n6. Ensure proper styling in the exported PDF",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Text Export Functionality",
            "description": "Implement text export functionality for packing lists with proper formatting",
            "dependencies": [],
            "details": "1. Complete the exportAsText function in exportUtils.ts\n2. Create a UI component for triggering text exports\n3. Ensure proper formatting of categories, items, and metadata\n4. Handle special characters and multi-line content\n5. Test with various list configurations\n6. Add file naming options for exported text files",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Print-Friendly View Implementation",
            "description": "Create a dedicated print-friendly view for packing lists with optimized layout",
            "dependencies": [],
            "details": "1. Implement PrintView.tsx component with clean, printer-optimized styling\n2. Create the print/[listId]/page.tsx route for dedicated printing\n3. Add print-specific CSS with proper page breaks and layout\n4. Implement a print button that triggers browser print functionality\n5. Ensure consistent rendering across different browsers\n6. Test with various paper sizes and orientations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Sharing Functionality",
            "description": "Implement sharing features including shareable URLs and QR code generation",
            "dependencies": [],
            "details": "1. Create a database schema for shared lists with access controls\n2. Implement API endpoints for generating and validating share links\n3. Create a view-only mode for shared lists\n4. Implement copy-to-clipboard functionality for share links\n5. Add QR code generation for easy mobile sharing\n6. Implement share permission management (view-only vs. collaborative)\n7. Add expiration options for shared links",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Mobile Responsiveness and Gestures",
        "description": "Optimize the application for mobile devices with responsive design, touch gestures, and mobile-specific UI enhancements.",
        "details": "1. Implement responsive layouts:\n   - Use Tailwind's responsive classes for all components\n   - Create mobile-specific variants of complex components\n   - Implement collapsible sections for better mobile viewing\n   - Optimize touch targets for mobile (min 44x44px)\n\n2. Add touch gestures:\n```bash\nnpm install @use-gesture/react\n```\n\n```typescript\n// components/gestures/SwipeableItem.tsx\nimport { useSpring, animated } from '@react-spring/web';\nimport { useDrag } from '@use-gesture/react';\n\nconst SwipeableItem = ({ item, onToggle, onDelete }) => {\n  const [{ x }, api] = useSpring(() => ({ x: 0 }));\n  \n  const bind = useDrag(({ down, movement: [mx], direction: [xDir], velocity: [vx], cancel }) => {\n    // Swipe logic implementation\n    if (down && Math.abs(mx) > 100) {\n      cancel();\n      if (mx > 0) {\n        onToggle(item.id);\n      } else {\n        onDelete(item.id);\n      }\n    }\n    api.start({ x: down ? mx : 0, immediate: down });\n  });\n  \n  return (\n    <animated.div {...bind()} style={{ x }} className=\"touch-none\">\n      {/* Item content */}\n    </animated.div>\n  );\n};\n```\n\n3. Implement mobile-specific features:\n   - Bottom navigation bar for main actions\n   - Pull-to-refresh for list updates\n   - Floating action button for adding items\n   - Mobile-optimized forms with larger inputs\n\n4. Add offline support:\n   - Service worker registration\n   - Offline indicator\n   - Queue changes for sync when back online",
        "testStrategy": "1. Test on various mobile devices and screen sizes\n2. Verify touch gestures work correctly on iOS and Android\n3. Test offline functionality and data persistence\n4. Verify performance on low-end mobile devices\n5. Test with different network conditions (slow, intermittent)\n6. Verify touch targets are accessible and easy to hit\n7. Test with different browser zoom levels",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Accessibility and Final Polish",
        "description": "Ensure the application meets WCAG 2.1 AA standards, implement dark mode, and add final polish with animations and error handling.",
        "details": "1. Implement accessibility features:\n   - Proper heading hierarchy\n   - ARIA labels and roles\n   - Focus management\n   - Skip links\n   - Keyboard navigation\n   - Screen reader testing\n\n2. Add dark mode support:\n```typescript\n// components/theme/ThemeToggle.tsx\n// Toggle button for switching between light and dark mode\n\n// lib/themeUtils.ts\n// Utilities for managing theme preferences\n```\n\n3. Implement animations and transitions:\n```bash\nnpm install framer-motion\n```\n\n```typescript\n// components/animations/FadeIn.tsx\nimport { motion } from 'framer-motion';\n\nconst FadeIn = ({ children }) => (\n  <motion.div\n    initial={{ opacity: 0 }}\n    animate={{ opacity: 1 }}\n    exit={{ opacity: 0 }}\n    transition={{ duration: 0.3 }}\n  >\n    {children}\n  </motion.div>\n);\n```\n\n4. Add error handling:\n   - Error boundaries for component failures\n   - Toast notifications for errors\n   - Fallback UI for failed data loading\n   - Form validation error messages\n\n5. Implement performance optimizations:\n   - Memoization of expensive calculations\n   - Virtualized lists for large datasets\n   - Code splitting for large components\n   - Image optimization",
        "testStrategy": "1. Run accessibility audits with Lighthouse and axe\n2. Test with screen readers (NVDA, VoiceOver)\n3. Verify keyboard navigation works for all interactions\n4. Test dark mode in different lighting conditions\n5. Verify animations don't cause layout shifts\n6. Test error handling with simulated failures\n7. Measure and verify performance metrics (LCP, FID, CLS)\n8. Conduct final cross-browser testing",
        "priority": "high",
        "dependencies": [
          1,
          3,
          4,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Analyze Pack List app state with Kapture MCP",
        "description": "Use the Kapture MCP server to analyze the current state and functionality of the Pack List application by viewing and interacting with it in the browser",
        "details": "Connect to the running Pack List application through Kapture MCP server and perform a comprehensive analysis of its current state, features, and functionality",
        "testStrategy": "Manual testing through browser interaction via Kapture MCP",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "User Authentication & Account System",
        "description": "Implement a comprehensive user authentication system with registration, login, password reset, email verification, and user profile management to replace the current mock authentication.",
        "details": "1. Set up authentication libraries and dependencies:\n```bash\nnpm install next-auth bcryptjs jsonwebtoken nodemailer\n```\n\n2. Create authentication API endpoints:\n```typescript\n// pages/api/auth/[...nextauth].ts\nimport NextAuth from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { verifyPassword } from '../../../lib/auth/password';\nimport { prisma } from '../../../lib/db';\n\nexport default NextAuth({\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60, // 30 days\n  },\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        const user = await prisma.user.findUnique({\n          where: { email: credentials.email }\n        });\n        \n        if (!user) {\n          throw new Error('No user found with this email');\n        }\n        \n        const isValid = await verifyPassword(credentials.password, user.password);\n        \n        if (!isValid) {\n          throw new Error('Invalid password');\n        }\n        \n        return { id: user.id, email: user.email, name: user.name };\n      }\n    }),\n    // Add OAuth providers as needed (Google, GitHub, etc.)\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.userId = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      session.userId = token.userId;\n      return session;\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/auth/signout',\n    error: '/auth/error',\n    verifyRequest: '/auth/verify-request',\n  }\n});\n```\n\n3. Create authentication utility functions:\n```typescript\n// lib/auth/password.ts\nimport bcrypt from 'bcryptjs';\n\nexport async function hashPassword(password: string): Promise<string> {\n  const salt = await bcrypt.genSalt(12);\n  return bcrypt.hash(password, salt);\n}\n\nexport async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n  return bcrypt.compare(password, hashedPassword);\n}\n```\n\n4. Implement email verification system:\n```typescript\n// lib/auth/email.ts\nimport nodemailer from 'nodemailer';\nimport jwt from 'jsonwebtoken';\n\nexport async function sendVerificationEmail(email: string, userId: string) {\n  const token = jwt.sign(\n    { userId },\n    process.env.EMAIL_SECRET,\n    { expiresIn: '1d' }\n  );\n  \n  const verificationUrl = `${process.env.NEXT_PUBLIC_BASE_URL}/auth/verify?token=${token}`;\n  \n  const transporter = nodemailer.createTransport({\n    host: process.env.EMAIL_SERVER_HOST,\n    port: process.env.EMAIL_SERVER_PORT,\n    secure: true,\n    auth: {\n      user: process.env.EMAIL_SERVER_USER,\n      pass: process.env.EMAIL_SERVER_PASSWORD,\n    },\n  });\n  \n  await transporter.sendMail({\n    from: process.env.EMAIL_FROM,\n    to: email,\n    subject: 'Verify your email address',\n    html: `\n      <p>Please click the link below to verify your email address:</p>\n      <p><a href=\"${verificationUrl}\">Verify Email</a></p>\n    `,\n  });\n}\n```\n\n5. Create authentication UI components:\n```typescript\n// components/auth/SignInForm.tsx\n// components/auth/SignUpForm.tsx\n// components/auth/ResetPasswordForm.tsx\n// components/auth/VerifyEmailNotice.tsx\n```\n\n6. Implement user profile management:\n```typescript\n// components/profile/ProfileForm.tsx\nimport { useState } from 'react';\nimport { useSession } from 'next-auth/react';\n\nexport default function ProfileForm() {\n  const { data: session } = useSession();\n  const [name, setName] = useState(session?.user?.name || '');\n  const [isLoading, setIsLoading] = useState(false);\n  \n  async function handleSubmit(e) {\n    e.preventDefault();\n    setIsLoading(true);\n    \n    try {\n      const response = await fetch('/api/user/profile', {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name }),\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to update profile');\n      }\n      \n      // Update session\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Form fields */}\n    </form>\n  );\n}\n```\n\n7. Create authentication pages:\n```typescript\n// pages/auth/signin.tsx\n// pages/auth/signup.tsx\n// pages/auth/reset-password.tsx\n// pages/auth/verify.tsx\n// pages/profile.tsx\n```\n\n8. Update User model in database schema:\n```typescript\n// prisma/schema.prisma\nmodel User {\n  id            String    @id @default(cuid())\n  name          String?\n  email         String    @unique\n  emailVerified DateTime?\n  password      String\n  image         String?\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n  lists         List[]\n}\n```\n\n9. Implement authentication context and hooks:\n```typescript\n// lib/auth/AuthContext.tsx\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { useSession } from 'next-auth/react';\n\nconst AuthContext = createContext(null);\n\nexport function AuthProvider({ children }) {\n  const { data: session, status } = useSession();\n  const [user, setUser] = useState(null);\n  \n  useEffect(() => {\n    if (session?.user) {\n      setUser(session.user);\n    } else {\n      setUser(null);\n    }\n  }, [session]);\n  \n  return (\n    <AuthContext.Provider value={{ user, isLoading: status === 'loading', isAuthenticated: !!user }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport const useAuth = () => useContext(AuthContext);\n```\n\n10. Implement protected routes:\n```typescript\n// components/auth/ProtectedRoute.tsx\nimport { useRouter } from 'next/router';\nimport { useAuth } from '../../lib/auth/AuthContext';\n\nexport default function ProtectedRoute({ children }) {\n  const { isAuthenticated, isLoading } = useAuth();\n  const router = useRouter();\n  \n  useEffect(() => {\n    if (!isLoading && !isAuthenticated) {\n      router.push('/auth/signin?callbackUrl=' + encodeURIComponent(router.asPath));\n    }\n  }, [isAuthenticated, isLoading, router]);\n  \n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n  \n  return isAuthenticated ? children : null;\n}\n```\n\n11. Update environment variables:\n```\n# .env.local\nNEXTAUTH_URL=http://localhost:3000\nNEXTAUTH_SECRET=your-secret-key\nEMAIL_SERVER_HOST=smtp.example.com\nEMAIL_SERVER_PORT=465\nEMAIL_SERVER_USER=your-email@example.com\nEMAIL_SERVER_PASSWORD=your-password\nEMAIL_FROM=noreply@yourapp.com\nEMAIL_SECRET=email-verification-secret\n```\n\n12. Integrate authentication with existing app state:\n```typescript\n// Update Zustand store to work with authenticated users\n// lib/stores/listStore.ts\nimport { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\ninterface ListState {\n  // ... existing state\n  userId: string | null;\n  setUserId: (userId: string | null) => void;\n}\n\nexport const useListStore = create<ListState>()(\n  persist(\n    (set) => ({\n      // ... existing state and actions\n      userId: null,\n      setUserId: (userId) => set({ userId }),\n    }),\n    {\n      name: 'list-storage',\n    }\n  )\n);\n```",
        "testStrategy": "1. Unit test authentication utility functions:\n   - Test password hashing and verification\n   - Test JWT token generation and validation\n   - Test email sending functionality with mock transporter\n\n2. Test authentication API endpoints:\n   - Test user registration with valid and invalid data\n   - Test login with correct and incorrect credentials\n   - Test password reset flow\n   - Test email verification process\n\n3. Test authentication UI components:\n   - Test form validation for all auth forms\n   - Test error message display\n   - Test loading states during authentication\n   - Test redirect behavior after successful authentication\n\n4. Integration tests for authentication flows:\n   - Complete registration flow with email verification\n   - Login flow with session persistence\n   - Password reset flow\n   - Profile update flow\n\n5. Security testing:\n   - Test password strength requirements\n   - Test rate limiting for login attempts\n   - Test CSRF protection\n   - Test session timeout and renewal\n   - Test secure cookie settings\n\n6. Test user profile management:\n   - Test profile data updates\n   - Test profile image upload and management\n   - Test account deletion functionality\n\n7. Test authentication with existing functionality:\n   - Verify lists are associated with authenticated users\n   - Test data persistence across sessions\n   - Test multi-device access to the same account\n\n8. Test error handling and edge cases:\n   - Test behavior when email service is unavailable\n   - Test account recovery options\n   - Test concurrent session management\n   - Test browser storage limitations\n\n9. Accessibility testing:\n   - Test keyboard navigation for all auth forms\n   - Test screen reader compatibility\n   - Test color contrast for auth UI elements\n   - Test form error announcements\n\n10. Cross-browser and device testing:\n    - Test authentication flows on different browsers\n    - Test on mobile devices\n    - Test with various privacy settings (cookies, localStorage)",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up authentication infrastructure",
            "description": "Install required dependencies and configure authentication libraries including NextAuth.js, bcryptjs, jsonwebtoken, and nodemailer.",
            "dependencies": [],
            "details": "Install necessary packages with npm install next-auth bcryptjs jsonwebtoken nodemailer. Configure NextAuth.js with JWT strategy and credentials provider. Set up environment variables for authentication secrets and email configuration. Create basic authentication utility functions for password hashing and verification.",
            "status": "done",
            "testStrategy": "Verify all dependencies are correctly installed. Test environment variable configuration. Ensure NextAuth.js is properly initialized with the correct configuration."
          },
          {
            "id": 2,
            "title": "Implement user registration and login",
            "description": "Create API endpoints and UI components for user registration and login functionality.",
            "dependencies": [
              "12.1"
            ],
            "details": "Develop API routes for user registration and login. Create SignInForm and SignUpForm components with form validation. Implement user creation in the database with proper password hashing. Set up session management and JWT token handling. Design and implement responsive authentication pages.",
            "status": "done",
            "testStrategy": "Test user registration with valid and invalid data. Verify password hashing works correctly. Test login functionality with correct and incorrect credentials. Ensure proper error handling and user feedback. Test form validation for all required fields."
          },
          {
            "id": 3,
            "title": "Implement email verification system",
            "description": "Create email verification functionality to validate user email addresses during registration.",
            "dependencies": [
              "12.2"
            ],
            "details": "Set up nodemailer for sending verification emails. Create JWT-based verification tokens with appropriate expiration. Implement API endpoint for email verification. Design verification email template. Create verification success/failure pages. Update user model to track email verification status.",
            "status": "done",
            "testStrategy": "Test email sending functionality with mock transporter. Verify token generation and validation. Test verification flow with valid and expired tokens. Ensure proper user feedback during the verification process."
          },
          {
            "id": 4,
            "title": "Implement password reset functionality",
            "description": "Create password reset flow including request form, email with reset link, and password update form.",
            "dependencies": [
              "12.3"
            ],
            "details": "Develop API endpoint for password reset requests. Create secure token generation for password resets with appropriate expiration. Implement password reset email sending. Design and implement password reset request and confirmation forms. Add server-side validation for password strength and token validity.",
            "status": "done",
            "testStrategy": "Test password reset request with valid and invalid emails. Verify reset token generation and validation. Test password update with valid and invalid tokens. Ensure proper error handling and user feedback throughout the process."
          },
          {
            "id": 5,
            "title": "Implement user profile management",
            "description": "Create user profile page with ability to view and update personal information, change password, and manage account settings.",
            "dependencies": [
              "12.2"
            ],
            "details": "Design and implement user profile page with editable fields. Create API endpoints for updating user information. Implement password change functionality with current password verification. Add profile image upload capability. Create protected routes and authentication context for secure access. Integrate authentication with existing app state and Zustand store.",
            "status": "done",
            "testStrategy": "Test profile information updates with valid and invalid data. Verify password change functionality works correctly. Test profile image upload and display. Ensure protected routes redirect unauthenticated users appropriately. Test integration with existing app state."
          }
        ]
      },
      {
        "id": 13,
        "title": "Enhanced Navigation System Implementation",
        "description": "Create an improved navigation system with breadcrumbs, sidebar navigation, mobile-responsive menu, and contextual navigation based on user role and current page.",
        "details": "1. Implement breadcrumb navigation:\n```typescript\n// components/navigation/Breadcrumbs.tsx\nimport { usePathname } from 'next/navigation';\nimport Link from 'next/link';\nimport { ChevronRight } from 'lucide-react';\n\nexport const Breadcrumbs = () => {\n  const pathname = usePathname();\n  const segments = pathname.split('/').filter(Boolean);\n  \n  return (\n    <nav aria-label=\"Breadcrumb\" className=\"flex items-center text-sm text-muted-foreground\">\n      <ol className=\"flex items-center space-x-2\">\n        <li>\n          <Link href=\"/\" className=\"hover:text-primary transition-colors\">\n            Home\n          </Link>\n        </li>\n        {segments.map((segment, index) => {\n          const href = `/${segments.slice(0, index + 1).join('/')}`;\n          const isLast = index === segments.length - 1;\n          \n          return (\n            <li key={segment} className=\"flex items-center\">\n              <ChevronRight className=\"h-4 w-4 mx-1\" />\n              {isLast ? (\n                <span className=\"font-medium text-foreground\" aria-current=\"page\">\n                  {segment.charAt(0).toUpperCase() + segment.slice(1).replace(/-/g, ' ')}\n                </span>\n              ) : (\n                <Link href={href} className=\"hover:text-primary transition-colors\">\n                  {segment.charAt(0).toUpperCase() + segment.slice(1).replace(/-/g, ' ')}\n                </Link>\n              )}\n            </li>\n          );\n        })}\n      </ol>\n    </nav>\n  );\n};\n```\n\n2. Create sidebar navigation component:\n```typescript\n// components/navigation/Sidebar.tsx\nimport { usePathname } from 'next/navigation';\nimport Link from 'next/link';\nimport { cn } from '@/lib/utils';\nimport { useAuth } from '@/hooks/useAuth';\n\ntype NavItem = {\n  title: string;\n  href: string;\n  icon: React.ReactNode;\n  roles?: string[];\n};\n\nexport const Sidebar = ({ items }: { items: NavItem[] }) => {\n  const pathname = usePathname();\n  const { user } = useAuth();\n  \n  // Filter items based on user role\n  const filteredItems = items.filter(item => \n    !item.roles || (user?.role && item.roles.includes(user.role))\n  );\n  \n  return (\n    <div className=\"h-screen w-64 border-r bg-background p-4\">\n      <div className=\"space-y-4\">\n        {filteredItems.map((item) => {\n          const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);\n          \n          return (\n            <Link\n              key={item.href}\n              href={item.href}\n              className={cn(\n                \"flex items-center space-x-2 rounded-md px-3 py-2 text-sm font-medium transition-colors\",\n                isActive \n                  ? \"bg-primary/10 text-primary\" \n                  : \"text-muted-foreground hover:bg-accent hover:text-accent-foreground\"\n              )}\n            >\n              {item.icon}\n              <span>{item.title}</span>\n            </Link>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n```\n\n3. Implement mobile-responsive navigation menu:\n```typescript\n// components/navigation/MobileNav.tsx\nimport { useState } from 'react';\nimport { Menu, X } from 'lucide-react';\nimport { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';\nimport { Button } from '@/components/ui/button';\nimport { Sidebar } from './Sidebar';\nimport { navigationItems } from '@/config/navigation';\n\nexport const MobileNav = () => {\n  const [open, setOpen] = useState(false);\n  \n  return (\n    <Sheet open={open} onOpenChange={setOpen}>\n      <SheetTrigger asChild>\n        <Button variant=\"ghost\" size=\"icon\" className=\"md:hidden\">\n          <Menu className=\"h-5 w-5\" />\n          <span className=\"sr-only\">Toggle menu</span>\n        </Button>\n      </SheetTrigger>\n      <SheetContent side=\"left\" className=\"p-0\">\n        <Button \n          variant=\"ghost\" \n          size=\"icon\" \n          className=\"absolute right-4 top-4\"\n          onClick={() => setOpen(false)}\n        >\n          <X className=\"h-5 w-5\" />\n          <span className=\"sr-only\">Close menu</span>\n        </Button>\n        <Sidebar items={navigationItems} />\n      </SheetContent>\n    </Sheet>\n  );\n};\n```\n\n4. Create navigation configuration:\n```typescript\n// config/navigation.ts\nimport { \n  Home, \n  List, \n  Settings, \n  User, \n  Template, \n  Share, \n  PlusCircle,\n  Users\n} from 'lucide-react';\n\nexport const navigationItems = [\n  {\n    title: 'Dashboard',\n    href: '/dashboard',\n    icon: <Home className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'My Lists',\n    href: '/lists',\n    icon: <List className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'Create New List',\n    href: '/lists/new',\n    icon: <PlusCircle className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'Templates',\n    href: '/templates',\n    icon: <Template className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'Shared Lists',\n    href: '/shared',\n    icon: <Share className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'Profile',\n    href: '/profile',\n    icon: <User className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'Settings',\n    href: '/settings',\n    icon: <Settings className=\"h-5 w-5\" />,\n  },\n  {\n    title: 'User Management',\n    href: '/admin/users',\n    icon: <Users className=\"h-5 w-5\" />,\n    roles: ['admin'],\n  },\n];\n```\n\n5. Create contextual navigation component:\n```typescript\n// components/navigation/ContextualNav.tsx\nimport { usePathname } from 'next/navigation';\nimport Link from 'next/link';\nimport { Button } from '@/components/ui/button';\nimport { useAuth } from '@/hooks/useAuth';\n\ntype ContextAction = {\n  title: string;\n  href?: string;\n  onClick?: () => void;\n  icon: React.ReactNode;\n  variant?: 'default' | 'secondary' | 'outline' | 'ghost';\n  roles?: string[];\n};\n\nconst getContextualActions = (pathname: string): ContextAction[] => {\n  // Define contextual actions based on current path\n  if (pathname.startsWith('/lists/')) {\n    const listId = pathname.split('/')[2];\n    return [\n      {\n        title: 'Edit List',\n        href: `/lists/${listId}/edit`,\n        icon: <PencilIcon className=\"h-4 w-4 mr-2\" />,\n      },\n      {\n        title: 'Share List',\n        href: `/lists/${listId}/share`,\n        icon: <ShareIcon className=\"h-4 w-4 mr-2\" />,\n      },\n      {\n        title: 'Export List',\n        href: `/lists/${listId}/export`,\n        icon: <DownloadIcon className=\"h-4 w-4 mr-2\" />,\n      },\n      // More contextual actions...\n    ];\n  }\n  \n  // Add more path-specific actions\n  \n  return [];\n};\n\nexport const ContextualNav = () => {\n  const pathname = usePathname();\n  const { user } = useAuth();\n  \n  const actions = getContextualActions(pathname).filter(action => \n    !action.roles || (user?.role && action.roles.includes(user.role))\n  );\n  \n  if (actions.length === 0) return null;\n  \n  return (\n    <div className=\"flex items-center space-x-2 py-2\">\n      {actions.map((action, index) => (\n        action.href ? (\n          <Link key={index} href={action.href}>\n            <Button variant={action.variant || 'outline'} size=\"sm\">\n              {action.icon}\n              {action.title}\n            </Button>\n          </Link>\n        ) : (\n          <Button \n            key={index} \n            variant={action.variant || 'outline'} \n            size=\"sm\"\n            onClick={action.onClick}\n          >\n            {action.icon}\n            {action.title}\n          </Button>\n        )\n      ))}\n    </div>\n  );\n};\n```\n\n6. Create main layout component with all navigation elements:\n```typescript\n// components/layout/MainLayout.tsx\nimport { ReactNode } from 'react';\nimport { Breadcrumbs } from '@/components/navigation/Breadcrumbs';\nimport { Sidebar } from '@/components/navigation/Sidebar';\nimport { MobileNav } from '@/components/navigation/MobileNav';\nimport { ContextualNav } from '@/components/navigation/ContextualNav';\nimport { navigationItems } from '@/config/navigation';\n\nexport const MainLayout = ({ children }: { children: ReactNode }) => {\n  return (\n    <div className=\"flex min-h-screen\">\n      {/* Desktop Sidebar - hidden on mobile */}\n      <div className=\"hidden md:block\">\n        <Sidebar items={navigationItems} />\n      </div>\n      \n      <div className=\"flex-1 flex flex-col\">\n        <header className=\"border-b bg-background p-4\">\n          <div className=\"flex items-center justify-between\">\n            {/* Mobile Navigation */}\n            <MobileNav />\n            \n            {/* App Logo/Title */}\n            <h1 className=\"text-xl font-bold\">Pack List</h1>\n            \n            {/* User Menu Component (not implemented in this task) */}\n          </div>\n          \n          {/* Breadcrumbs */}\n          <div className=\"mt-2\">\n            <Breadcrumbs />\n          </div>\n          \n          {/* Contextual Navigation */}\n          <ContextualNav />\n        </header>\n        \n        <main className=\"flex-1 p-6\">\n          {children}\n        </main>\n      </div>\n    </div>\n  );\n};\n```\n\n7. Update app layout to use the new navigation system:\n```typescript\n// app/layout.tsx\nimport { MainLayout } from '@/components/layout/MainLayout';\nimport { ThemeProvider } from '@/components/theme/ThemeProvider';\nimport { AuthProvider } from '@/providers/AuthProvider';\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body>\n        <ThemeProvider>\n          <AuthProvider>\n            <MainLayout>{children}</MainLayout>\n          </AuthProvider>\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n```\n\n8. Add navigation state management:\n```typescript\n// store/navigationStore.ts\nimport { create } from 'zustand';\n\ntype NavigationState = {\n  isSidebarOpen: boolean;\n  toggleSidebar: () => void;\n  setSidebarOpen: (open: boolean) => void;\n  activeSection: string | null;\n  setActiveSection: (section: string | null) => void;\n};\n\nexport const useNavigationStore = create<NavigationState>((set) => ({\n  isSidebarOpen: false,\n  toggleSidebar: () => set((state) => ({ isSidebarOpen: !state.isSidebarOpen })),\n  setSidebarOpen: (open) => set({ isSidebarOpen: open }),\n  activeSection: null,\n  setActiveSection: (section) => set({ activeSection: section }),\n}));\n```\n\n9. Implement navigation hooks for reusable navigation logic:\n```typescript\n// hooks/useNavigation.ts\nimport { usePathname } from 'next/navigation';\nimport { useNavigationStore } from '@/store/navigationStore';\nimport { useAuth } from '@/hooks/useAuth';\nimport { navigationItems } from '@/config/navigation';\n\nexport const useNavigation = () => {\n  const pathname = usePathname();\n  const { user } = useAuth();\n  const { isSidebarOpen, toggleSidebar, setSidebarOpen } = useNavigationStore();\n  \n  // Get current section based on pathname\n  const getCurrentSection = () => {\n    const currentItem = navigationItems.find(item => \n      pathname === item.href || pathname.startsWith(`${item.href}/`)\n    );\n    return currentItem?.title || null;\n  };\n  \n  // Filter navigation items based on user role\n  const getFilteredNavItems = () => {\n    return navigationItems.filter(item => \n      !item.roles || (user?.role && item.roles.includes(user.role))\n    );\n  };\n  \n  return {\n    pathname,\n    currentSection: getCurrentSection(),\n    navItems: getFilteredNavItems(),\n    isSidebarOpen,\n    toggleSidebar,\n    setSidebarOpen,\n  };\n};\n```",
        "testStrategy": "1. Test breadcrumb navigation:\n   - Verify breadcrumbs correctly reflect the current path hierarchy\n   - Test breadcrumb links navigate to the correct pages\n   - Verify breadcrumbs update dynamically when navigating between pages\n   - Test breadcrumb accessibility with screen readers\n\n2. Test sidebar navigation:\n   - Verify all navigation items appear correctly\n   - Test active state highlighting for the current page\n   - Verify role-based navigation items only appear for authorized users\n   - Test keyboard navigation through sidebar items\n   - Verify sidebar responsiveness on different screen sizes\n\n3. Test mobile navigation:\n   - Verify mobile menu toggle button appears only on mobile viewports\n   - Test opening and closing the mobile navigation drawer\n   - Verify all navigation items are accessible in the mobile menu\n   - Test touch interactions and gestures\n   - Verify mobile navigation works across different mobile devices and orientations\n\n4. Test contextual navigation:\n   - Verify contextual actions appear based on the current page context\n   - Test that role-based contextual actions only appear for authorized users\n   - Verify all contextual action links navigate to the correct pages\n   - Test contextual action buttons trigger the correct functions\n\n5. Test navigation state management:\n   - Verify sidebar open/close state persists correctly\n   - Test that navigation state updates correctly when navigating between pages\n   - Verify active section is highlighted correctly\n\n6. Test accessibility:\n   - Verify all navigation elements are keyboard accessible\n   - Test navigation with screen readers to ensure proper ARIA attributes\n   - Verify color contrast meets WCAG AA standards\n   - Test focus management when opening/closing mobile navigation\n\n7. Test responsive behavior:\n   - Verify navigation layout adapts correctly across breakpoints\n   - Test navigation on various device sizes (mobile, tablet, desktop)\n   - Verify navigation elements don't overflow or break layout on small screens\n\n8. Cross-browser testing:\n   - Test navigation in Chrome, Firefox, Safari, and Edge\n   - Verify consistent behavior across browsers\n   - Test on iOS and Android mobile browsers",
        "status": "pending",
        "dependencies": [
          1,
          9,
          10,
          12
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Responsive Navigation Layout",
            "description": "Create the main layout component that integrates all navigation elements and ensures proper responsiveness across devices",
            "dependencies": [],
            "details": "Develop the MainLayout.tsx component that combines the sidebar, mobile navigation, breadcrumbs, and contextual navigation. Ensure the layout adapts properly to different screen sizes with appropriate breakpoints. Implement proper container structure and styling for all navigation elements.",
            "status": "pending",
            "testStrategy": "Test responsive behavior across multiple device sizes (mobile, tablet, desktop). Verify navigation elements appear and hide appropriately at different breakpoints. Ensure layout maintains integrity when resizing the browser window. Test accessibility of the navigation structure with screen readers."
          },
          {
            "id": 2,
            "title": "Enhance Contextual Navigation System",
            "description": "Improve the contextual navigation component to dynamically display relevant actions based on current page and user role",
            "dependencies": [
              "13.1"
            ],
            "details": "Refine the ContextualNav.tsx component to provide more comprehensive path-based action detection. Implement additional helper functions to determine appropriate contextual actions for each route. Add support for action variants (primary, secondary, etc.) and ensure proper styling. Integrate with authentication to filter actions by user permissions.",
            "status": "pending",
            "testStrategy": "Test contextual navigation rendering for different page paths. Verify correct actions appear based on user roles and permissions. Test action button functionality and styling variants. Ensure contextual navigation updates properly when navigating between pages."
          },
          {
            "id": 3,
            "title": "Implement Navigation State Management",
            "description": "Create a centralized navigation state management system using Zustand to handle sidebar visibility, active sections, and navigation history",
            "dependencies": [
              "13.1"
            ],
            "details": "Develop the navigationStore.ts using Zustand to manage navigation state. Implement state for sidebar visibility, active navigation section, navigation history, and mobile menu state. Create actions for toggling sidebar, setting active section, and managing navigation history. Ensure state persists appropriately across page navigation.",
            "status": "pending",
            "testStrategy": "Test state management functions for toggling sidebar and setting active sections. Verify state persistence during navigation. Test integration with components that consume the navigation state. Ensure proper state updates when interacting with navigation elements."
          },
          {
            "id": 4,
            "title": "Create Navigation Hooks and Utilities",
            "description": "Develop custom hooks and utility functions to simplify navigation logic and provide consistent behavior across components",
            "dependencies": [
              "13.3"
            ],
            "details": "Create useNavigation.ts hook to centralize navigation logic. Implement functions for determining current section, filtering navigation items by user role, and managing navigation state. Add utilities for path manipulation, breadcrumb generation, and contextual action determination. Ensure hooks properly integrate with Next.js router and navigation store.",
            "status": "pending",
            "testStrategy": "Test hook behavior with different pathnames and user roles. Verify correct section detection and navigation item filtering. Test integration with components that use the navigation hooks. Ensure proper reactivity to route changes and user authentication state."
          },
          {
            "id": 5,
            "title": "Implement Role-Based Navigation Filtering",
            "description": "Enhance navigation components to filter items based on user roles and permissions, ensuring users only see navigation options relevant to them",
            "dependencies": [
              "13.2",
              "13.4"
            ],
            "details": "Update Sidebar.tsx, MobileNav.tsx, and ContextualNav.tsx to properly filter navigation items based on user roles. Implement role checking in navigation configuration. Add support for more granular permission-based filtering beyond simple role checks. Ensure navigation updates reactively when user authentication state changes.",
            "status": "pending",
            "testStrategy": "Test navigation rendering with different user roles (admin, regular user, etc.). Verify appropriate items are shown/hidden based on user permissions. Test navigation updates when user role changes. Ensure proper fallback behavior when authentication state is loading or undefined."
          }
        ]
      },
      {
        "id": 14,
        "title": "Admin Dashboard Foundation",
        "description": "Build a comprehensive admin dashboard with user management, system analytics, content moderation, and administrative controls for the pack-list application.",
        "details": "1. Set up the admin dashboard layout and navigation:\n```typescript\n// components/admin/AdminLayout.tsx\nimport { ReactNode } from 'react';\nimport { AdminSidebar } from './AdminSidebar';\nimport { AdminHeader } from './AdminHeader';\n\ninterface AdminLayoutProps {\n  children: ReactNode;\n}\n\nexport function AdminLayout({ children }: AdminLayoutProps) {\n  return (\n    <div className=\"grid grid-cols-[280px_1fr] min-h-screen\">\n      <AdminSidebar />\n      <div className=\"flex flex-col\">\n        <AdminHeader />\n        <main className=\"flex-1 p-6 overflow-auto\">{children}</main>\n      </div>\n    </div>\n  );\n}\n```\n\n2. Create admin dashboard pages:\n```typescript\n// app/admin/page.tsx - Dashboard overview\n// app/admin/users/page.tsx - User management\n// app/admin/analytics/page.tsx - System analytics\n// app/admin/content/page.tsx - Content moderation\n// app/admin/settings/page.tsx - System settings\n```\n\n3. Implement user management functionality:\n```typescript\n// components/admin/users/UserTable.tsx\nimport { DataTable } from '@/components/ui/data-table';\nimport { columns } from './columns';\nimport { useUserStore } from '@/stores/userStore';\n\nexport function UserTable() {\n  const { users, isLoading } = useUserStore();\n  \n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between\">\n        <h2 className=\"text-2xl font-bold\">User Management</h2>\n        <Button variant=\"default\">Add User</Button>\n      </div>\n      {isLoading ? (\n        <Skeleton className=\"w-full h-[400px]\" />\n      ) : (\n        <DataTable columns={columns} data={users} />\n      )}\n    </div>\n  );\n}\n```\n\n4. Create analytics dashboard with charts:\n```bash\nnpm install recharts\n```\n\n```typescript\n// components/admin/analytics/AnalyticsDashboard.tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { BarChart, Bar, LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer } from 'recharts';\n\nexport function AnalyticsDashboard() {\n  // Mock data - would be replaced with real analytics data\n  const userData = [\n    { name: 'Jan', users: 400 },\n    { name: 'Feb', users: 600 },\n    // ...more data\n  ];\n  \n  const listData = [\n    { name: 'Jan', lists: 200 },\n    { name: 'Feb', lists: 350 },\n    // ...more data\n  ];\n  \n  return (\n    <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-3\">\n      <Card>\n        <CardHeader>\n          <CardTitle>User Growth</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <ResponsiveContainer width=\"100%\" height={300}>\n            <LineChart data={userData}>\n              <XAxis dataKey=\"name\" />\n              <YAxis />\n              <Tooltip />\n              <Line type=\"monotone\" dataKey=\"users\" stroke=\"#8884d8\" />\n            </LineChart>\n          </ResponsiveContainer>\n        </CardContent>\n      </Card>\n      \n      {/* Additional analytics cards */}\n    </div>\n  );\n}\n```\n\n5. Implement content moderation tools:\n```typescript\n// components/admin/content/ContentModerationQueue.tsx\nimport { useState } from 'react';\nimport { DataTable } from '@/components/ui/data-table';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { contentModerationColumns } from './columns';\n\nexport function ContentModerationQueue() {\n  const [items, setItems] = useState([/* mock data */]);\n  \n  const handleApprove = (id: string) => {\n    // Approve content logic\n  };\n  \n  const handleReject = (id: string) => {\n    // Reject content logic\n  };\n  \n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <h2 className=\"text-2xl font-bold\">Content Moderation</h2>\n        <div className=\"flex gap-2\">\n          <Badge variant=\"outline\">{items.length} Pending</Badge>\n          <Button>Refresh</Button>\n        </div>\n      </div>\n      \n      <DataTable \n        columns={contentModerationColumns} \n        data={items}\n        onApprove={handleApprove}\n        onReject={handleReject}\n      />\n    </div>\n  );\n}\n```\n\n6. Create administrative controls and settings:\n```typescript\n// components/admin/settings/SystemSettings.tsx\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useForm } from 'react-hook-form';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { Form, FormControl, FormField, FormItem, FormLabel } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Switch } from '@/components/ui/switch';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\n\nconst settingsSchema = z.object({\n  siteName: z.string().min(2),\n  allowRegistration: z.boolean(),\n  maxListsPerUser: z.number().min(1),\n  // Other settings\n});\n\nexport function SystemSettings() {\n  const form = useForm({\n    resolver: zodResolver(settingsSchema),\n    defaultValues: {\n      siteName: 'Pack List',\n      allowRegistration: true,\n      maxListsPerUser: 50,\n    },\n  });\n  \n  const onSubmit = (data) => {\n    // Save settings logic\n    console.log(data);\n  };\n  \n  return (\n    <Tabs defaultValue=\"general\">\n      <TabsList>\n        <TabsTrigger value=\"general\">General</TabsTrigger>\n        <TabsTrigger value=\"security\">Security</TabsTrigger>\n        <TabsTrigger value=\"advanced\">Advanced</TabsTrigger>\n      </TabsList>\n      \n      <TabsContent value=\"general\">\n        <Form {...form}>\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n            <FormField\n              control={form.control}\n              name=\"siteName\"\n              render={({ field }) => (\n                <FormItem>\n                  <FormLabel>Site Name</FormLabel>\n                  <FormControl>\n                    <Input {...field} />\n                  </FormControl>\n                </FormItem>\n              )}\n            />\n            \n            <FormField\n              control={form.control}\n              name=\"allowRegistration\"\n              render={({ field }) => (\n                <FormItem className=\"flex items-center justify-between\">\n                  <FormLabel>Allow User Registration</FormLabel>\n                  <FormControl>\n                    <Switch \n                      checked={field.value} \n                      onCheckedChange={field.onChange} \n                    />\n                  </FormControl>\n                </FormItem>\n              )}\n            />\n            \n            <Button type=\"submit\">Save Settings</Button>\n          </form>\n        </Form>\n      </TabsContent>\n      \n      {/* Other tabs content */}\n    </Tabs>\n  );\n}\n```\n\n7. Implement role-based access control:\n```typescript\n// lib/auth/permissions.ts\nexport enum UserRole {\n  USER = 'user',\n  MODERATOR = 'moderator',\n  ADMIN = 'admin',\n}\n\nexport const permissions = {\n  viewAdminDashboard: [UserRole.ADMIN, UserRole.MODERATOR],\n  manageUsers: [UserRole.ADMIN],\n  moderateContent: [UserRole.ADMIN, UserRole.MODERATOR],\n  changeSettings: [UserRole.ADMIN],\n};\n\nexport function hasPermission(userRole: UserRole, permission: keyof typeof permissions): boolean {\n  return permissions[permission].includes(userRole);\n}\n```\n\n8. Create admin dashboard middleware for route protection:\n```typescript\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\nimport { UserRole } from '@/lib/auth/permissions';\n\nexport async function middleware(request: NextRequest) {\n  const token = await getToken({ req: request });\n  \n  // Check if path starts with /admin\n  if (request.nextUrl.pathname.startsWith('/admin')) {\n    if (!token) {\n      return NextResponse.redirect(new URL('/login', request.url));\n    }\n    \n    // Check if user has admin role\n    if (token.role !== UserRole.ADMIN && token.role !== UserRole.MODERATOR) {\n      return NextResponse.redirect(new URL('/', request.url));\n    }\n  }\n  \n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ['/admin/:path*'],\n};\n```",
        "testStrategy": "1. Test admin dashboard layout and navigation:\n   - Verify responsive design works on different screen sizes\n   - Test sidebar navigation links lead to correct pages\n   - Verify breadcrumb navigation shows correct path\n   - Test mobile responsiveness of the admin layout\n\n2. Test user management functionality:\n   - Verify users can be viewed in a paginated table\n   - Test user search and filtering functionality\n   - Verify user details can be viewed and edited\n   - Test user role assignment functionality\n   - Verify user account suspension/deletion works correctly\n   - Test validation for user data fields\n\n3. Test analytics dashboard:\n   - Verify charts render correctly with test data\n   - Test date range filters for analytics data\n   - Verify data export functionality works\n   - Test responsiveness of charts on different screen sizes\n   - Verify tooltips and interactive elements of charts\n\n4. Test content moderation tools:\n   - Verify content items appear in moderation queue\n   - Test approve/reject functionality for content items\n   - Verify filtering of content by type, status, and date\n   - Test bulk moderation actions\n   - Verify content preview functionality\n\n5. Test administrative controls and settings:\n   - Verify system settings can be viewed and updated\n   - Test validation for settings form fields\n   - Verify settings are persisted after page refresh\n   - Test each tab in the settings interface\n\n6. Test role-based access control:\n   - Verify users with admin role can access all dashboard features\n   - Test that moderators can only access permitted sections\n   - Verify regular users cannot access admin dashboard\n   - Test middleware redirects for unauthorized access attempts\n\n7. Integration testing:\n   - Test integration with authentication system\n   - Verify admin actions are properly logged in the system\n   - Test integration with user data store\n   - Verify changes made in admin dashboard reflect in the main application\n\n8. Security testing:\n   - Test CSRF protection for admin forms\n   - Verify proper input sanitization for all form fields\n   - Test rate limiting for sensitive operations\n   - Verify proper error handling that doesn't expose sensitive information",
        "status": "pending",
        "dependencies": [
          1,
          2,
          12,
          13
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Role-Based Access Control System",
            "description": "Create a comprehensive role-based access control system that defines user roles (admin, moderator, user) and their associated permissions for the admin dashboard.",
            "dependencies": [],
            "details": "Create the permissions system with role definitions, permission checks, and middleware for route protection. Implement the UserRole enum, permissions object, and hasPermission function. Set up the middleware to protect admin routes based on user roles.",
            "status": "pending",
            "testStrategy": "Test role-based access with different user types. Verify middleware correctly redirects unauthorized users. Test permission checks for various dashboard features. Ensure admin-only features are properly restricted."
          },
          {
            "id": 2,
            "title": "Develop User Management Interface",
            "description": "Build a complete user management interface with user listing, filtering, role editing, and account management capabilities.",
            "dependencies": [
              "14.1"
            ],
            "details": "Implement the UserTable component with data fetching from the user store. Create user detail view, edit forms, and role assignment functionality. Add user filtering, sorting, and pagination. Implement user creation, suspension, and deletion features.",
            "status": "pending",
            "testStrategy": "Test user listing with various data sets. Verify filtering and sorting functionality. Test user role changes and permission updates. Ensure proper error handling for user operations."
          },
          {
            "id": 3,
            "title": "Create Analytics Dashboard with Data Visualization",
            "description": "Develop an analytics dashboard with interactive charts and metrics displaying user growth, list creation, system usage, and other key performance indicators.",
            "dependencies": [],
            "details": "Set up Recharts for data visualization. Implement various chart components (line, bar, pie) for different metrics. Create analytics cards for key statistics. Add date range filtering for analytics data. Implement data fetching from analytics API endpoints.",
            "status": "pending",
            "testStrategy": "Test chart rendering with different data sets. Verify responsive behavior of charts. Test date range filtering functionality. Ensure analytics data is correctly displayed and formatted."
          },
          {
            "id": 4,
            "title": "Build Content Moderation Tools",
            "description": "Implement content moderation tools for reviewing and managing user-generated content, including lists, templates, and user profiles.",
            "dependencies": [
              "14.1"
            ],
            "details": "Create the ContentModerationQueue component with approval/rejection functionality. Implement content filtering by type and status. Add content preview capabilities. Create moderation history and audit logs. Implement automated content flagging system based on keywords.",
            "status": "pending",
            "testStrategy": "Test content approval and rejection workflows. Verify content filtering and sorting. Test moderation history tracking. Ensure proper handling of different content types in the moderation queue."
          },
          {
            "id": 5,
            "title": "Develop System Settings and Configuration Interface",
            "description": "Create a comprehensive settings interface for managing application configuration, including general settings, security options, and advanced system parameters.",
            "dependencies": [
              "14.1"
            ],
            "details": "Implement the SystemSettings component with tabbed interface for different setting categories. Create form validation using Zod. Add settings persistence to database. Implement settings categories: general, security, advanced. Create settings change history and audit logging.",
            "status": "pending",
            "testStrategy": "Test settings form validation. Verify settings persistence after changes. Test different setting combinations and their effects. Ensure settings history is properly tracked. Test settings UI across different screen sizes."
          }
        ]
      },
      {
        "id": 15,
        "title": "Database Integration with Prisma ORM",
        "description": "Set up database integration using PostgreSQL with Prisma ORM, implement connection pooling, and configure environment variables for database access across development and production environments.",
        "details": "1. Install Prisma and related dependencies:\n```bash\nnpm install prisma @prisma/client\nnpx prisma init\n```\n\n2. Configure database connection in `.env` file:\n```\nDATABASE_URL=\"postgresql://username:password@localhost:5432/packlistdb?schema=public\"\n```\n\n3. Set up Prisma schema in `prisma/schema.prisma`:\n```prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Initial models will be defined in subsequent tasks\n```\n\n4. Implement connection pooling for production environments:\n```typescript\n// lib/db.ts\nimport { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  })\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n```\n\n5. Create database utility functions:\n```typescript\n// lib/db-utils.ts\nimport { prisma } from './db'\n\nexport async function checkDatabaseConnection() {\n  try {\n    await prisma.$queryRaw`SELECT 1`\n    return true\n  } catch (error) {\n    console.error('Database connection failed:', error)\n    return false\n  }\n}\n```\n\n6. Set up environment-specific configuration:\n```typescript\n// config/database.ts\nexport const databaseConfig = {\n  connectionTimeout: process.env.DB_CONNECTION_TIMEOUT || 5000,\n  maxConnections: process.env.NODE_ENV === 'production' ? 20 : 10,\n  idleTimeout: process.env.NODE_ENV === 'production' ? 30000 : 10000,\n}\n```\n\n7. Create a database initialization script:\n```typescript\n// scripts/init-db.ts\nimport { prisma } from '../lib/db'\n\nasync function main() {\n  // Verify database connection\n  try {\n    await prisma.$queryRaw`SELECT 1`\n    console.log('Database connection successful')\n  } catch (error) {\n    console.error('Failed to connect to database:', error)\n    process.exit(1)\n  }\n}\n\nmain()\n  .catch((e) => {\n    console.error(e)\n    process.exit(1)\n  })\n  .finally(async () => {\n    await prisma.$disconnect()\n  })\n```\n\n8. Update Next.js configuration to support database connection:\n```typescript\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    serverComponentsExternalPackages: ['@prisma/client', 'bcrypt'],\n  },\n}\n\nmodule.exports = nextConfig\n```\n\n9. Add database environment variables to deployment configuration:\n```yaml\n# Example for Vercel deployment in vercel.json\n{\n  \"env\": {\n    \"DATABASE_URL\": \"@database_url\"\n  }\n}\n```\n\n10. Document database schema management process:\n- Create migrations: `npx prisma migrate dev --name init`\n- Apply migrations in production: `npx prisma migrate deploy`\n- Generate Prisma client: `npx prisma generate`",
        "testStrategy": "1. Test database connection:\n   - Create a test script that attempts to connect to the database\n   - Verify connection pooling works by simulating multiple concurrent connections\n   - Test connection recovery after database restarts\n\n2. Test environment configuration:\n   - Verify the application can read database credentials from environment variables\n   - Test with different environment configurations (development, test, production)\n   - Ensure sensitive credentials are properly protected\n\n3. Test Prisma ORM functionality:\n   - Create a simple model and verify CRUD operations work correctly\n   - Test transaction support for operations that require atomicity\n   - Verify error handling for database operations\n\n4. Performance testing:\n   - Measure connection establishment time\n   - Test connection pool under load with concurrent requests\n   - Verify connection reuse is working as expected\n\n5. Security testing:\n   - Ensure database credentials are not exposed in client-side code\n   - Verify SQL injection protection with Prisma's parameterized queries\n   - Test database user permissions match principle of least privilege\n\n6. Integration testing:\n   - Create a test suite that verifies the database integration works with the application\n   - Test database migrations apply correctly\n   - Verify the application handles database unavailability gracefully\n\n7. CI/CD pipeline testing:\n   - Set up a test database for CI/CD pipeline\n   - Verify migrations run automatically in the pipeline\n   - Test database seeding for development and testing environments",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Prisma ORM",
            "description": "Set up Prisma ORM with PostgreSQL by installing dependencies and initializing the project configuration",
            "dependencies": [],
            "details": "Install Prisma and related dependencies using npm. Initialize Prisma with the PostgreSQL connection. Configure the database URL in the .env file. Set up the basic Prisma schema structure in prisma/schema.prisma with the appropriate generator and datasource configurations.",
            "status": "done",
            "testStrategy": "Verify successful installation by checking package.json for dependencies. Confirm Prisma initialization by checking for the presence of prisma directory and schema file. Test the database connection string format in .env file."
          },
          {
            "id": 2,
            "title": "Implement Connection Pooling",
            "description": "Create a database connection management system with proper connection pooling for development and production environments",
            "dependencies": [
              "15.1"
            ],
            "details": "Develop the db.ts utility to implement connection pooling with PrismaClient. Configure environment-specific logging levels. Implement global instance management to prevent multiple connections in development. Set up connection timeout and pool size configurations based on the environment.",
            "status": "done",
            "testStrategy": "Test connection pooling by simulating multiple concurrent database requests. Verify connection reuse through Prisma logs. Test different environment configurations to ensure proper pool sizing. Measure performance under load to validate pooling effectiveness."
          },
          {
            "id": 3,
            "title": "Create Database Utility Functions",
            "description": "Develop utility functions for database operations, connection testing, and error handling",
            "dependencies": [
              "15.2"
            ],
            "details": "Create db-utils.ts with functions for checking database connectivity. Implement error handling for database operations. Add utility functions for common database operations. Create environment-specific configuration in config/database.ts with appropriate timeout and connection settings.",
            "status": "done",
            "testStrategy": "Unit test each utility function with both successful and error scenarios. Verify connection checking works correctly when database is available and unavailable. Test timeout handling with deliberately slow connections."
          },
          {
            "id": 4,
            "title": "Set Up Database Initialization and Migration Scripts",
            "description": "Create scripts for database initialization, migration management, and deployment preparation",
            "dependencies": [
              "15.3"
            ],
            "details": "Develop init-db.ts script to verify database connection on startup. Create documentation and scripts for managing database migrations. Set up procedures for applying migrations in different environments. Configure Prisma client generation process. Implement error handling and reporting for migration failures.",
            "status": "done",
            "testStrategy": "Test initialization script in both successful and failure scenarios. Verify migration process works correctly with test schema changes. Test migration rollback capabilities. Confirm proper error reporting when database is unavailable."
          },
          {
            "id": 5,
            "title": "Configure Environment-Specific Database Settings",
            "description": "Set up environment-specific database configurations for development, testing, and production environments",
            "dependencies": [
              "15.4"
            ],
            "details": "Update Next.js configuration to support database connections with serverComponentsExternalPackages. Create deployment configuration for database environment variables. Set up environment-specific database settings for connection limits, timeouts, and logging. Document the process for managing database credentials across environments. Configure CI/CD pipeline to handle database migrations.",
            "status": "done",
            "testStrategy": "Test application with different environment configurations to ensure proper loading of settings. Verify deployment configuration works in staging environment. Test database access with different environment variables. Confirm proper isolation between development and production database settings."
          }
        ]
      },
      {
        "id": 16,
        "title": "API Route Architecture Implementation",
        "description": "Design and implement a RESTful API architecture with proper error handling, middleware, validation, and authentication guards for all user and admin endpoints.",
        "details": "1. Set up API route structure following Next.js API routes pattern:\n```typescript\n// app/api/route.ts (API entry point)\n// app/api/[version]/route.ts (API versioning)\n// app/api/[version]/users/route.ts (User endpoints)\n// app/api/[version]/admin/route.ts (Admin endpoints)\n```\n\n2. Implement middleware for common API functionality:\n```typescript\n// middleware/api/auth.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\n\nexport async function authMiddleware(req: NextRequest) {\n  const token = await getToken({ req });\n  \n  if (!token) {\n    return NextResponse.json(\n      { error: 'Unauthorized access' },\n      { status: 401 }\n    );\n  }\n  \n  return NextResponse.next();\n}\n\n// middleware/api/adminAuth.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\nimport { prisma } from '@/lib/db';\n\nexport async function adminAuthMiddleware(req: NextRequest) {\n  const token = await getToken({ req });\n  \n  if (!token || !token.sub) {\n    return NextResponse.json(\n      { error: 'Unauthorized access' },\n      { status: 401 }\n    );\n  }\n  \n  // Check if user is admin\n  const user = await prisma.user.findUnique({\n    where: { id: token.sub },\n    select: { role: true }\n  });\n  \n  if (!user || user.role !== 'ADMIN') {\n    return NextResponse.json(\n      { error: 'Forbidden: Admin access required' },\n      { status: 403 }\n    );\n  }\n  \n  return NextResponse.next();\n}\n```\n\n3. Create a centralized error handling utility:\n```typescript\n// lib/api/errorHandler.ts\nimport { NextResponse } from 'next/server';\nimport { ZodError } from 'zod';\nimport { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';\n\nexport function handleApiError(error: unknown) {\n  console.error('API Error:', error);\n  \n  // Handle validation errors\n  if (error instanceof ZodError) {\n    return NextResponse.json(\n      { \n        error: 'Validation error', \n        details: error.errors \n      },\n      { status: 400 }\n    );\n  }\n  \n  // Handle Prisma errors\n  if (error instanceof PrismaClientKnownRequestError) {\n    // Handle specific Prisma error codes\n    if (error.code === 'P2002') {\n      return NextResponse.json(\n        { error: 'Resource already exists' },\n        { status: 409 }\n      );\n    }\n    \n    if (error.code === 'P2025') {\n      return NextResponse.json(\n        { error: 'Resource not found' },\n        { status: 404 }\n      );\n    }\n  }\n  \n  // Default error response\n  return NextResponse.json(\n    { error: 'Internal server error' },\n    { status: 500 }\n  );\n}\n```\n\n4. Implement request validation with Zod:\n```typescript\n// lib/api/validation.ts\nimport { z } from 'zod';\n\nexport const createUserSchema = z.object({\n  email: z.string().email(),\n  name: z.string().min(2).max(100),\n  password: z.string().min(8).max(100)\n});\n\nexport const updateUserSchema = z.object({\n  name: z.string().min(2).max(100).optional(),\n  email: z.string().email().optional()\n});\n\nexport const createListSchema = z.object({\n  name: z.string().min(1).max(100),\n  description: z.string().max(500).optional(),\n  isTemplate: z.boolean().default(false)\n});\n\n// More validation schemas...\n```\n\n5. Create base API route handlers:\n```typescript\n// app/api/v1/users/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { authMiddleware } from '@/middleware/api/auth';\nimport { handleApiError } from '@/lib/api/errorHandler';\nimport { createUserSchema, updateUserSchema } from '@/lib/api/validation';\nimport { prisma } from '@/lib/db';\n\nexport async function GET(req: NextRequest) {\n  try {\n    // Apply auth middleware\n    const middlewareResponse = await authMiddleware(req);\n    if (middlewareResponse.status !== 200) {\n      return middlewareResponse;\n    }\n    \n    const token = await getToken({ req });\n    const userId = token?.sub;\n    \n    const user = await prisma.user.findUnique({\n      where: { id: userId },\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        createdAt: true,\n        updatedAt: true\n      }\n    });\n    \n    if (!user) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      );\n    }\n    \n    return NextResponse.json(user);\n  } catch (error) {\n    return handleApiError(error);\n  }\n}\n\nexport async function PATCH(req: NextRequest) {\n  try {\n    // Apply auth middleware\n    const middlewareResponse = await authMiddleware(req);\n    if (middlewareResponse.status !== 200) {\n      return middlewareResponse;\n    }\n    \n    // Parse and validate request body\n    const body = await req.json();\n    const validatedData = updateUserSchema.parse(body);\n    \n    const token = await getToken({ req });\n    const userId = token?.sub;\n    \n    const updatedUser = await prisma.user.update({\n      where: { id: userId },\n      data: validatedData,\n      select: {\n        id: true,\n        email: true,\n        name: true,\n        createdAt: true,\n        updatedAt: true\n      }\n    });\n    \n    return NextResponse.json(updatedUser);\n  } catch (error) {\n    return handleApiError(error);\n  }\n}\n```\n\n6. Implement admin API routes with admin authentication:\n```typescript\n// app/api/v1/admin/users/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { adminAuthMiddleware } from '@/middleware/api/adminAuth';\nimport { handleApiError } from '@/lib/api/errorHandler';\nimport { prisma } from '@/lib/db';\n\nexport async function GET(req: NextRequest) {\n  try {\n    // Apply admin auth middleware\n    const middlewareResponse = await adminAuthMiddleware(req);\n    if (middlewareResponse.status !== 200) {\n      return middlewareResponse;\n    }\n    \n    // Parse query parameters\n    const { searchParams } = new URL(req.url);\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = parseInt(searchParams.get('limit') || '10');\n    const skip = (page - 1) * limit;\n    \n    // Get users with pagination\n    const [users, total] = await Promise.all([\n      prisma.user.findMany({\n        skip,\n        take: limit,\n        orderBy: { createdAt: 'desc' },\n        select: {\n          id: true,\n          email: true,\n          name: true,\n          role: true,\n          createdAt: true,\n          updatedAt: true,\n          _count: {\n            select: {\n              lists: true\n            }\n          }\n        }\n      }),\n      prisma.user.count()\n    ]);\n    \n    return NextResponse.json({\n      users,\n      pagination: {\n        total,\n        page,\n        limit,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    return handleApiError(error);\n  }\n}\n```\n\n7. Implement rate limiting for API routes:\n```typescript\n// middleware/api/rateLimit.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { Redis } from '@upstash/redis';\n\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_URL || '',\n  token: process.env.UPSTASH_REDIS_TOKEN || ''\n});\n\nexport async function rateLimitMiddleware(\n  req: NextRequest,\n  { limit = 10, window = 60 } = {}\n) {\n  const ip = req.headers.get('x-forwarded-for') || 'anonymous';\n  const key = `rate-limit:${ip}`;\n  \n  const count = await redis.incr(key);\n  \n  // Set expiry on first request\n  if (count === 1) {\n    await redis.expire(key, window);\n  }\n  \n  // Set rate limit headers\n  const response = NextResponse.next();\n  response.headers.set('X-RateLimit-Limit', limit.toString());\n  response.headers.set('X-RateLimit-Remaining', Math.max(0, limit - count).toString());\n  \n  // If rate limit exceeded\n  if (count > limit) {\n    return NextResponse.json(\n      { error: 'Too many requests' },\n      { \n        status: 429,\n        headers: {\n          'X-RateLimit-Limit': limit.toString(),\n          'X-RateLimit-Remaining': '0',\n          'Retry-After': window.toString()\n        }\n      }\n    );\n  }\n  \n  return response;\n}\n```\n\n8. Create API documentation with Swagger/OpenAPI:\n```typescript\n// app/api/docs/route.ts\nimport { NextResponse } from 'next/server';\nimport { createSwaggerSpec } from 'next-swagger-doc';\n\nexport async function GET() {\n  const spec = createSwaggerSpec({\n    apiFolder: 'app/api',\n    definition: {\n      openapi: '3.0.0',\n      info: {\n        title: 'Pack List API',\n        version: '1.0.0',\n        description: 'API documentation for the Pack List application'\n      },\n      servers: [\n        {\n          url: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api',\n          description: 'API server'\n        }\n      ]\n    }\n  });\n  \n  return NextResponse.json(spec);\n}\n```\n\n9. Implement CORS handling for API routes:\n```typescript\n// middleware/api/cors.ts\nimport { NextRequest, NextResponse } from 'next/server';\n\nconst allowedOrigins = [\n  'http://localhost:3000',\n  'https://packlistapp.com'\n];\n\nexport function corsMiddleware(req: NextRequest) {\n  const origin = req.headers.get('origin') || '';\n  \n  // Check if origin is allowed\n  if (allowedOrigins.includes(origin)) {\n    const response = NextResponse.next();\n    \n    // Set CORS headers\n    response.headers.set('Access-Control-Allow-Origin', origin);\n    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS');\n    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    response.headers.set('Access-Control-Allow-Credentials', 'true');\n    \n    return response;\n  }\n  \n  // Handle preflight requests\n  if (req.method === 'OPTIONS') {\n    return new NextResponse(null, {\n      status: 204,\n      headers: {\n        'Access-Control-Allow-Origin': origin,\n        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n        'Access-Control-Allow-Credentials': 'true',\n        'Access-Control-Max-Age': '86400'\n      }\n    });\n  }\n  \n  return NextResponse.next();\n}\n```\n\n10. Create a comprehensive API response utility:\n```typescript\n// lib/api/response.ts\nimport { NextResponse } from 'next/server';\n\ntype ApiResponse<T> = {\n  data?: T;\n  error?: string;\n  message?: string;\n  status: number;\n};\n\nexport function createApiResponse<T>({\n  data,\n  error,\n  message,\n  status = 200\n}: ApiResponse<T>) {\n  const body: any = {};\n  \n  if (data !== undefined) body.data = data;\n  if (error !== undefined) body.error = error;\n  if (message !== undefined) body.message = message;\n  \n  return NextResponse.json(body, { status });\n}\n```",
        "testStrategy": "1. Test API route structure and basic functionality:\n   - Verify all API endpoints return expected responses\n   - Test API versioning works correctly\n   - Ensure proper HTTP status codes are returned for different scenarios\n   - Test API response format consistency across endpoints\n\n2. Test authentication middleware:\n   - Verify unauthenticated requests to protected routes are rejected with 401\n   - Test authenticated requests pass through middleware correctly\n   - Verify admin-only routes reject non-admin users with 403\n   - Test token validation and expiration handling\n\n3. Test error handling:\n   - Verify validation errors return 400 with appropriate details\n   - Test database errors are properly handled and transformed\n   - Ensure server errors return 500 status with sanitized messages\n   - Verify custom error types are handled correctly\n\n4. Test request validation:\n   - Test each validation schema with valid and invalid data\n   - Verify required fields are enforced\n   - Test field type validation (strings, numbers, booleans, etc.)\n   - Verify field length and format constraints\n\n5. Test rate limiting:\n   - Verify requests are counted correctly per IP\n   - Test rate limit headers are set properly\n   - Ensure requests exceeding limits receive 429 responses\n   - Test rate limit window expiration resets counters\n\n6. Test CORS functionality:\n   - Verify allowed origins can access the API\n   - Test disallowed origins are rejected\n   - Ensure preflight requests are handled correctly\n   - Verify appropriate CORS headers are set in responses\n\n7. Test API documentation:\n   - Verify Swagger/OpenAPI documentation is generated correctly\n   - Test documentation endpoints are accessible\n   - Ensure all API routes are documented properly\n   - Verify schema definitions match actual request/response formats\n\n8. Test specific API endpoints:\n   - Test user endpoints (GET, POST, PATCH, DELETE)\n   - Verify admin endpoints with appropriate permissions\n   - Test list and item management endpoints\n   - Ensure pagination, filtering, and sorting work correctly\n\n9. Integration testing:\n   - Test API routes with the actual database\n   - Verify middleware chain works end-to-end\n   - Test authentication flow from login to protected routes\n   - Ensure data persistence and retrieval work correctly\n\n10. Performance testing:\n    - Test API response times under load\n    - Verify rate limiting effectively prevents abuse\n    - Test concurrent request handling\n    - Ensure database queries are optimized",
        "status": "done",
        "dependencies": [
          12,
          15
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement API Route Structure and Versioning",
            "description": "Set up the foundational API route structure following Next.js API routes pattern with proper versioning support",
            "dependencies": [],
            "details": "Create the base API route files and folder structure:\n- app/api/route.ts as the API entry point\n- app/api/[version]/route.ts for API versioning\n- app/api/v1/users/route.ts for user endpoints\n- app/api/v1/admin/route.ts for admin endpoints\n- Implement version handling logic to support multiple API versions",
            "status": "done",
            "testStrategy": "Test API route structure accessibility, verify correct routing based on version parameter, ensure API entry point returns appropriate metadata, and validate that invalid version parameters return proper error responses"
          },
          {
            "id": 2,
            "title": "Develop Authentication and Authorization Middleware",
            "description": "Create middleware for user authentication and admin authorization with proper token validation",
            "dependencies": [
              "16.1"
            ],
            "details": "Implement and refine authentication middleware:\n- Complete the authMiddleware for regular user authentication\n- Finalize the adminAuthMiddleware with role-based access control\n- Add JWT token validation and verification\n- Implement session management and token refresh logic\n- Create middleware composition utilities for applying multiple middleware functions",
            "status": "done",
            "testStrategy": "Test authentication middleware with valid and invalid tokens, verify admin authorization correctly restricts access based on user roles, test token expiration handling, and validate proper error responses for unauthorized requests"
          },
          {
            "id": 3,
            "title": "Create Error Handling and Response Utilities",
            "description": "Develop comprehensive error handling utilities and standardized API response formats",
            "dependencies": [
              "16.1"
            ],
            "details": "Enhance the error handling system:\n- Complete the handleApiError utility to handle all error types\n- Implement the createApiResponse utility for consistent response formatting\n- Add detailed logging for API errors\n- Create custom error classes for specific API error scenarios\n- Implement request validation error formatting",
            "status": "done",
            "testStrategy": "Test error handling with various error types (validation errors, database errors, authentication errors), verify consistent error response format, validate proper HTTP status codes are returned, and ensure sensitive error details are not exposed in production"
          },
          {
            "id": 4,
            "title": "Implement Request Validation with Zod",
            "description": "Create comprehensive request validation schemas for all API endpoints using Zod",
            "dependencies": [
              "16.1",
              "16.3"
            ],
            "details": "Expand the validation system:\n- Complete all validation schemas for user operations\n- Create validation schemas for list and item operations\n- Implement validation schemas for admin operations\n- Add custom validation rules for complex data structures\n- Create validation middleware that automatically validates requests based on the endpoint",
            "status": "done",
            "testStrategy": "Test validation schemas with valid and invalid data, verify proper error messages for validation failures, test complex validation rules, and ensure validation is correctly applied to all API endpoints"
          },
          {
            "id": 5,
            "title": "Develop API Route Handlers for All Endpoints",
            "description": "Implement all API route handlers for user and admin operations with proper middleware integration",
            "dependencies": [
              "16.1",
              "16.2",
              "16.3",
              "16.4"
            ],
            "details": "Complete all API route handlers:\n- Implement CRUD operations for user profiles\n- Create endpoints for list management (create, read, update, delete)\n- Develop endpoints for list items and categories\n- Implement admin endpoints for user management\n- Add endpoints for analytics and reporting\n- Integrate rate limiting, CORS handling, and other middleware",
            "status": "done",
            "testStrategy": "Test all API endpoints with various request scenarios, verify proper authentication and authorization, validate request validation, test error handling, and ensure consistent response formats across all endpoints"
          }
        ]
      },
      {
        "id": 17,
        "title": "Convex Backend Migration",
        "description": "Replace PostgreSQL/Prisma database integration with Convex backend-as-a-service, update the authentication system, and migrate existing components to use Convex hooks and functions.",
        "details": "1. Install Convex and required dependencies:\n```bash\nnpm install convex @clerk/clerk-react\n```\n\n2. Initialize Convex in the project:\n```bash\nnpx convex init\n```\n\n3. Configure Convex environment variables in `.env.local`:\n```\nNEXT_PUBLIC_CONVEX_URL=your_convex_deployment_url\nCLERK_PUBLISHABLE_KEY=your_clerk_publishable_key\nCLERK_SECRET_KEY=your_clerk_secret_key\n```\n\n4. Set up Convex provider in the application root:\n```typescript\n// app/providers.tsx\nimport { ConvexProvider, ConvexReactClient } from \"convex/react\";\nimport { ClerkProvider, useAuth } from \"@clerk/clerk-react\";\nimport { ConvexClerkAuth } from \"convex/react-clerk\";\n\nconst convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);\n\nexport function Providers({ children }: { children: React.ReactNode }) {\n  return (\n    <ClerkProvider publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY!}>\n      <ConvexProvider client={convex}>\n        <ConvexClerkAuth useAuth={useAuth}>\n          {children}\n        </ConvexClerkAuth>\n      </ConvexProvider>\n    </ClerkProvider>\n  );\n}\n```\n\n5. Define Convex schema for existing data models:\n```typescript\n// convex/schema.ts\nimport { defineSchema, defineTable } from \"convex/server\";\nimport { v } from \"convex/values\";\n\nexport default defineSchema({\n  users: defineTable({\n    name: v.string(),\n    email: v.string(),\n    image: v.optional(v.string()),\n  }).index(\"by_email\", [\"email\"]),\n  \n  lists: defineTable({\n    name: v.string(),\n    description: v.optional(v.string()),\n    userId: v.string(),\n    isPublic: v.boolean(),\n  }).index(\"by_user\", [\"userId\"]),\n  \n  categories: defineTable({\n    name: v.string(),\n    listId: v.id(\"lists\"),\n    order: v.number(),\n  }).index(\"by_list\", [\"listId\"]),\n  \n  items: defineTable({\n    name: v.string(),\n    categoryId: v.id(\"categories\"),\n    checked: v.boolean(),\n    quantity: v.optional(v.number()),\n    notes: v.optional(v.string()),\n    order: v.number(),\n  }).index(\"by_category\", [\"categoryId\"]),\n});\n```\n\n6. Create Convex query and mutation functions:\n```typescript\n// convex/lists.ts\nimport { query, mutation } from \"./_generated/server\";\nimport { v } from \"convex/values\";\n\nexport const getLists = query({\n  args: {},\n  handler: async (ctx) => {\n    const identity = await ctx.auth.getUserIdentity();\n    if (!identity) {\n      throw new Error(\"Not authenticated\");\n    }\n    \n    const userId = identity.subject;\n    return await ctx.db\n      .query(\"lists\")\n      .withIndex(\"by_user\", (q) => q.eq(\"userId\", userId))\n      .collect();\n  },\n});\n\nexport const createList = mutation({\n  args: {\n    name: v.string(),\n    description: v.optional(v.string()),\n    isPublic: v.boolean(),\n  },\n  handler: async (ctx, args) => {\n    const identity = await ctx.auth.getUserIdentity();\n    if (!identity) {\n      throw new Error(\"Not authenticated\");\n    }\n    \n    const userId = identity.subject;\n    return await ctx.db.insert(\"lists\", {\n      name: args.name,\n      description: args.description,\n      userId,\n      isPublic: args.isPublic,\n    });\n  },\n});\n\n// Similar functions for categories and items...\n```\n\n7. Migrate authentication from NextAuth to Clerk:\n```typescript\n// components/auth/SignInButton.tsx\nimport { SignInButton, UserButton } from \"@clerk/clerk-react\";\nimport { useAuth } from \"@clerk/clerk-react\";\n\nexport function AuthButton() {\n  const { isSignedIn } = useAuth();\n  \n  if (isSignedIn) {\n    return <UserButton afterSignOutUrl=\"/\" />;\n  }\n  \n  return <SignInButton mode=\"modal\" />;\n}\n```\n\n8. Update components to use Convex hooks:\n```typescript\n// components/lists/ListOverview.tsx\nimport { useQuery } from \"convex/react\";\nimport { api } from \"../../convex/_generated/api\";\n\nexport function ListOverview() {\n  const lists = useQuery(api.lists.getLists);\n  \n  if (lists === undefined) {\n    return <div>Loading...</div>;\n  }\n  \n  return (\n    <div>\n      {lists.map((list) => (\n        <ListCard key={list._id} list={list} />\n      ))}\n    </div>\n  );\n}\n```\n\n9. Update API routes to use Convex functions instead of direct database access:\n```typescript\n// Remove existing API routes that interact with Prisma\n// Replace with client-side Convex function calls\n```\n\n10. Migrate data from PostgreSQL to Convex:\n```typescript\n// scripts/migrate-to-convex.ts\nimport { PrismaClient } from '@prisma/client';\nimport { ConvexClient } from 'convex/browser';\n\nconst prisma = new PrismaClient();\nconst convex = new ConvexClient(process.env.NEXT_PUBLIC_CONVEX_URL!);\n\nasync function migrateData() {\n  // Fetch data from Prisma\n  const users = await prisma.user.findMany();\n  const lists = await prisma.list.findMany();\n  // ...\n  \n  // Insert into Convex\n  for (const user of users) {\n    await convex.mutation('users:create', {\n      name: user.name,\n      email: user.email,\n      // ...\n    });\n  }\n  // ...\n}\n\nmigrateData().catch(console.error);\n```\n\n11. Update environment configuration to remove PostgreSQL/Prisma related variables and add Convex variables.",
        "testStrategy": "1. Test Convex connection and configuration:\n   - Verify the application can connect to Convex backend\n   - Test environment variables are correctly loaded\n   - Verify Convex provider is properly set up in the application\n\n2. Test authentication with Clerk:\n   - Test user registration flow\n   - Test login functionality\n   - Test session persistence\n   - Verify protected routes are properly secured\n   - Test user profile management\n\n3. Test data migration:\n   - Create a script to verify all data has been correctly migrated from PostgreSQL to Convex\n   - Compare record counts between the old and new database\n   - Verify data integrity and relationships are maintained\n   - Test with a subset of production data in a staging environment\n\n4. Test Convex queries and mutations:\n   - Test all list operations (create, read, update, delete)\n   - Test category and item management\n   - Verify real-time updates work correctly when data changes\n   - Test pagination and filtering functionality\n   - Verify proper error handling for failed operations\n\n5. Test component integration:\n   - Verify all UI components correctly use Convex hooks\n   - Test loading states while data is being fetched\n   - Verify error states are handled gracefully\n   - Test optimistic updates for better user experience\n\n6. Performance testing:\n   - Compare response times between PostgreSQL/Prisma and Convex implementations\n   - Test application under load to verify Convex scaling\n   - Measure client-side performance impact of the migration\n\n7. Regression testing:\n   - Verify all existing functionality continues to work after migration\n   - Test all user flows to ensure they work with the new backend\n   - Verify mobile and desktop experiences are consistent",
        "status": "done",
        "dependencies": [
          12,
          15,
          16
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Convex and Clerk authentication",
            "description": "Install and configure Convex backend and Clerk authentication services, including environment variables and provider setup",
            "dependencies": [],
            "details": "Install required dependencies (convex, @clerk/clerk-react). Initialize Convex with 'npx convex init'. Configure environment variables in .env.local for Convex URL and Clerk keys. Set up ConvexProvider and ClerkProvider in app/providers.tsx to wrap the application. Test the connection to ensure proper configuration.",
            "status": "done",
            "testStrategy": "Verify successful installation of dependencies. Confirm Convex initialization creates necessary project files. Test environment variable loading. Ensure providers are correctly rendering children components. Test authentication state is properly maintained across the application."
          },
          {
            "id": 2,
            "title": "Define Convex schema and data models",
            "description": "Create schema definitions for all existing data models (users, lists, categories, items) with appropriate indexes",
            "dependencies": [
              "17.1"
            ],
            "details": "Create convex/schema.ts file defining tables for users, lists, categories, and items. Set up appropriate field types using Convex's validation system. Create indexes for efficient queries (by_email, by_user, by_list, by_category). Ensure schema matches the existing PostgreSQL/Prisma data structure to facilitate migration.",
            "status": "done",
            "testStrategy": "Validate schema definitions against existing data models. Test index creation and query performance. Verify field types and constraints match business requirements. Ensure schema supports all existing application features."
          },
          {
            "id": 3,
            "title": "Implement Convex query and mutation functions",
            "description": "Create backend functions for CRUD operations on all data models, including authentication checks",
            "dependencies": [
              "17.2"
            ],
            "details": "Create separate files for each data model (convex/users.ts, convex/lists.ts, etc.). Implement query functions to fetch data with proper authentication checks. Create mutation functions for creating, updating, and deleting records. Implement proper error handling and validation. Ensure functions maintain data integrity and security.",
            "status": "done",
            "testStrategy": "Test each query and mutation function with various inputs. Verify authentication checks prevent unauthorized access. Test error handling for invalid inputs. Compare function results with existing Prisma implementation to ensure feature parity."
          },
          {
            "id": 4,
            "title": "Update frontend components to use Convex hooks",
            "description": "Refactor React components to use Convex hooks (useQuery, useMutation) instead of direct API calls or Prisma",
            "dependencies": [
              "17.3"
            ],
            "details": "Replace existing API fetch calls with Convex hooks. Update components to use useQuery for data fetching and useMutation for data modifications. Implement loading states and error handling. Remove any direct Prisma database access. Update form submissions to use Convex mutations. Ensure real-time updates work correctly.",
            "status": "done",
            "testStrategy": "Test components with Convex hooks for proper rendering. Verify loading states display correctly. Test error handling and user feedback. Ensure real-time updates propagate correctly across components. Compare performance with previous implementation."
          },
          {
            "id": 5,
            "title": "Migrate existing data and finalize deployment",
            "description": "Create and execute a data migration script to transfer data from PostgreSQL to Convex, then finalize deployment configuration",
            "dependencies": [
              "17.2",
              "17.3",
              "17.4"
            ],
            "details": "Create a migration script to export data from PostgreSQL and import into Convex. Map existing data models to new Convex schema. Handle user authentication migration from NextAuth to Clerk. Update environment variables in deployment configuration. Remove PostgreSQL/Prisma dependencies. Test the complete system after migration. Document the new backend architecture.",
            "status": "done",
            "testStrategy": "Test data integrity after migration. Verify all user accounts are correctly transferred. Test application functionality end-to-end after migration. Monitor performance metrics after deployment. Verify authentication flows work correctly with Clerk."
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement Clerk authentication system",
        "description": "Replace current Convex authentication with Clerk following the official App Router integration guide",
        "details": "Follow clerk.md instructions strictly:\n1. Install @clerk/nextjs@latest\n2. Create middleware.ts with clerkMiddleware() from @clerk/nextjs/server\n3. Wrap app with ClerkProvider in app/layout.tsx\n4. Add Clerk UI components (SignInButton, SignUpButton, UserButton, SignedIn, SignedOut)\n5. Configure environment variables for Clerk\n6. Remove/adapt existing auth context to work with Clerk\n7. Ensure all imports are from correct packages (@clerk/nextjs or @clerk/nextjs/server)\n8. Test authentication flow end-to-end",
        "testStrategy": "Manual testing of sign up, sign in, sign out flows. Verify UserButton displays correctly. Test protected routes work as expected. Ensure no console errors.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Integrate Convex for data persistence",
        "description": "Replace local storage with Convex database and tie data to authenticated users",
        "details": "Implementation steps:\n1. Update Convex schema to include userId references\n2. Create Convex mutations for CRUD operations on lists, categories, items\n3. Create Convex queries to fetch user-specific data\n4. Update Zustand store to use Convex instead of localStorage\n5. Integrate Clerk user ID with Convex data\n6. Update homepage to show auth prompts for signed-out users\n7. Display user's lists when authenticated\n8. Ensure data isolation between users",
        "testStrategy": "Test user registration and login flow. Verify data isolation by creating lists with different users. Test CRUD operations for lists, categories, and items. Ensure real-time sync works across browser tabs.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-01T16:40:38.474Z",
      "updated": "2025-09-02T04:02:28.665Z",
      "description": "Tasks for master context"
    }
  }
}